<template>
  <div class="erlog-chart-wrap">
    <!-- 변경 시작: 줌 상태 유지 이벤트 -->
    <TimelineGanttChart
      ref="base"
      class="erlog-chart"
      :payload="payloadState"
      :height="220"
      :features="erlogFeatures"
      :tooltip-options="erlogTooltipOptions"
      :option-overrides="erlogOptionOverrides"
      @datazoom="onDataZoom"
      @chart-click="onChartClick"
    />
    <!-- 변경 끝: 줌 상태 유지 이벤트 -->
  </div>
</template>

<script>
import TimelineGanttChart from './TimelineGanttChart.vue';

const COLOR_RULES = Object.freeze({
  hasSy: '#3b82f6',
  incompleteSy: '#f59e0b',
  reject: '#ef4444'
});

const TOOLTIP_TEXT_COLOR = Object.freeze({
  [COLOR_RULES.hasSy]: '#ffffff',
  [COLOR_RULES.incompleteSy]: '#111827',
  [COLOR_RULES.reject]: '#ffffff'
});

const ERLOG_FEATURES = Object.freeze({
  topSlider: false,
  ySlider: false,
  markers: false,
  markerHoverButton: false,
  markerHoverEffect: false
});

export default {
  name: 'SyErLogChart',
  components: {
    TimelineGanttChart
  },
  data() {
    const now = Date.now();
    const domainStart = now - 60 * 60 * 1000;
    const domainEnd = now + 60 * 60 * 1000;
    return {
      items: [],
      allItems: [],
      // 변경 시작: 필터/도메인/줌 상태 분리
      // 변경: Y축 고정 유지를 위해 전체 카테고리 목록과 인덱스 맵 저장
      allCategories: [],
      categoryIndexMap: new Map(),
      // 변경: 도메인은 전체 데이터 기준으로 계산해 필터와 무관하게 고정
      domainState: {
        domainStart,
        domainEnd
      },
      // 변경: 필터 변경 시 줌 상태 유지
      zoomState: {
        viewStart: domainStart,
        viewEnd: domainEnd,
        cursorStart: null,
        cursorEnd: null
      },
      // 변경 끝: 필터/도메인/줌 상태 분리
      filterState: {
        hasSy: true,
        incompleteSy: true,
        reject: true
      },
      payloadState: {
        categories: [],
        intervals: [],
        domainStart,
        domainEnd,
        viewStart: domainStart,
        viewEnd: domainEnd,
        pinnedCategoryIndex: -1
      }
    };
  },
  computed: {
    erlogFeatures() {
      return ERLOG_FEATURES;
    },
    erlogTooltipOptions() {
      return {
        className: 'erlog-tooltip',
        backgroundColor: 'transparent',
        borderWidth: 0,
        padding: 0,
        extraCssText: 'box-shadow:none;'
      };
    },
    erlogOptionOverrides() {
      return {
        grid: [
          {
            id: 'grid-pinned',
            left: 80,
            right: 32,
            top: 20,
            height: 0,
            containLabel: true
          },
          {
            id: 'grid-main',
            left: 80,
            right: 32,
            top: 20,
            bottom: 120,
            containLabel: true
          }
        ],
        dataZoom: [
          {
            id: 'erlog-slider',
            type: 'slider',
            xAxisIndex: 1,
            filterMode: 'weakFilter',
            showDataShadow: false,
            brushSelect: false,
            bottom: 10,
            height: 22,
            labelFormatter: '',
            startValue: this.payloadState.viewStart,
            endValue: this.payloadState.viewEnd
          },
          {
            id: 'erlog-inside',
            type: 'inside',
            xAxisIndex: 1,
            filterMode: 'weakFilter',
            zoomOnMouseWheel: true,
            moveOnMouseWheel: false,
            moveOnMouseMove: false
          }
        ],
        xAxis: [
          {
            id: 'x-pinned',
            gridIndex: 0,
            type: 'time',
            min: this.payloadState.domainStart,
            max: this.payloadState.domainEnd,
            axisLabel: { show: false },
            axisTick: { show: false },
            axisLine: { show: false },
            splitLine: { show: false }
          },
          {
            id: 'x-main',
            gridIndex: 1,
            type: 'time',
            min: this.payloadState.domainStart,
            max: this.payloadState.domainEnd,
            minInterval: 30 * 60 * 1000,
            splitNumber: 48,
            axisLine: {
              lineStyle: {
                color: '#cbd5e1'
              }
            },
            axisLabel: {
              color: '#475569',
              interval: 0,
              hideOverlap: true,
              rotate: 90,
              margin: 6,
              inside: false,
              formatter: (value) => this.formatAxisLabel(value)
            },
            splitLine: {
              show: true,
              lineStyle: {
                color: '#e2e8f0'
              }
            }
          }
        ],
        yAxis: [
          {
            id: 'y-pinned',
            gridIndex: 0,
            type: 'category',
            inverse: true,
            data: [],
            axisTick: { show: false },
            axisLine: { show: false },
            axisLabel: { show: false }
          },
          {
            id: 'y-main',
            gridIndex: 1,
            type: 'category',
            inverse: true,
            data: this.payloadState.categories || [],
            axisTick: { show: false },
            axisLine: { show: false },
            axisLabel: {
              color: '#334155'
            }
          }
        ]
      };
    }
  },
  methods: {
    setData(data) {
      this.allItems = Array.isArray(data) ? data : [];
      // 변경: 데이터 갱신 시 전체 도메인/카테고리 상태를 계산
      const categoryState = this.buildCategoryState(this.allItems);
      this.allCategories = categoryState.categories;
      this.categoryIndexMap = categoryState.categoryIndexMap;
      this.domainState = this.buildDomainFromItems(this.allItems);
      this.zoomState = this.normalizeZoomState(this.zoomState, this.domainState);
      this.applyFilters();
    },
    setFilters(filters) {
      if (filters && typeof filters === 'object') {
        this.filterState = {
          ...this.filterState,
          ...filters
        };
      }
      this.applyFilters();
    },
    hideTooltip() {
      const base = this.$refs.base;
      if (base && typeof base.hideTooltip === 'function') {
        base.hideTooltip();
      }
    },
    // 변경 시작: 줌 상태 유지
    onDataZoom(payload) {
      if (!payload || typeof payload !== 'object') return;
      const domain = this.domainState || {};
      const next = {
        viewStart: payload.viewStart,
        viewEnd: payload.viewEnd,
        cursorStart: payload.cursorStart,
        cursorEnd: payload.cursorEnd
      };
      this.zoomState = this.normalizeZoomState(next, domain);
    },
    // 변경 끝: 줌 상태 유지
    onChartClick(params) {
      if (!params || params.seriesId !== 'bars-main' || !params.data) return;
      const raw = params.data.raw || null;
      if (!raw) return;
      const clickedTime = this.getClickedTime(params);
      this.hideTooltip();
      this.$emit('select-lot', {
        lot: raw,
        clickedTime
      });
    },
    getClickedTime(params) {
      const data = params && params.data ? params.data : null;
      const start = data && data.value ? data.value[1] : null;
      const end = data && data.value ? data.value[2] : null;
      const base = this.$refs.base;
      const chart = base && typeof base.getChartInstance === 'function' ? base.getChartInstance() : null;
      if (!chart || !params.event) {
        return start;
      }
      const offsetX = params.event.offsetX;
      const offsetY = params.event.offsetY;
      if (offsetX == null || offsetY == null) {
        return start;
      }
      const value = chart.convertFromPixel({ xAxisIndex: 1 }, [offsetX, offsetY]);
      const candidate = Array.isArray(value) ? value[0] : value;
      if (typeof candidate === 'number' && !Number.isNaN(candidate)) {
        if (start != null && end != null) {
          return Math.min(Math.max(candidate, start), end);
        }
        return candidate;
      }
      return start;
    },
    // 변경 시작: 필터 적용 구조(도메인/카테고리/줌 유지)
    applyFilters() {
      const filtered = this.filterItems(this.allItems, this.filterState);
      this.items = filtered;
      // 변경: intervals만 필터링하고 도메인/카테고리/줌은 유지
      const intervals = this.buildIntervalsFromItems(filtered, this.categoryIndexMap);
      const domain = this.domainState || {};
      let zoom = this.normalizeZoomState(this.zoomState, domain);
      const adjustedZoom = this.ensureZoomHasVisibleData(intervals, zoom, domain);
      if (adjustedZoom) {
        zoom = adjustedZoom;
        this.zoomState = adjustedZoom;
      }
      this.payloadState = {
        categories: this.allCategories || [],
        intervals,
        domainStart: domain.domainStart,
        domainEnd: domain.domainEnd,
        viewStart: zoom.viewStart,
        viewEnd: zoom.viewEnd,
        cursorStart: zoom.cursorStart,
        cursorEnd: zoom.cursorEnd,
        pinnedCategoryIndex: -1
      };
    },
    // 변경 끝: 필터 적용 구조(도메인/카테고리/줌 유지)
    filterItems(items, filters) {
      const list = Array.isArray(items) ? items : [];
      if (!filters || typeof filters !== 'object') return list;
      const hasActive = Object.values(filters).some(Boolean);
      if (!hasActive) return [];
      return list.filter((item) => {
        const status = this.resolveStatus(item);
        return !!filters[status];
      });
    },
    resolveStatus(item) {
      if (item && item.rejectWafer >= 1) {
        return 'reject';
      }
      if (item && item.avgSyCount >= 63) {
        return 'hasSy';
      }
      return 'incompleteSy';
    },
    // 변경 시작: 전체 데이터 기반 카테고리/도메인/intervals
    buildCategoryState(items) {
      const categories = [];
      const categoryIndexMap = new Map();
      // 변경: 전체 데이터 기준으로 안정적인 카테고리 목록 구성
      (Array.isArray(items) ? items : []).forEach((item) => {
        if (!item) return;
        const eqpId = item.eqpId ?? 'EQP-UNKNOWN';
        if (!categoryIndexMap.has(eqpId)) {
          categoryIndexMap.set(eqpId, categories.length);
          categories.push(eqpId);
        }
      });
      return { categories, categoryIndexMap };
    },
    buildDomainFromItems(items) {
      let minTime = null;
      let maxTime = null;
      // 변경: 필터된 데이터가 아닌 전체 데이터로 도메인 계산
      (Array.isArray(items) ? items : []).forEach((item) => {
        if (!item) return;
        const start = this.toTimeValue(item.lotStart);
        const end = this.toTimeValue(item.lotFinish);
        if (start == null || end == null || end <= start) return;
        minTime = minTime == null ? start : Math.min(minTime, start);
        maxTime = maxTime == null ? end : Math.max(maxTime, end);
      });

      if (minTime == null || maxTime == null) {
        const now = Date.now();
        minTime = now - 60 * 60 * 1000;
        maxTime = now + 60 * 60 * 1000;
      }

      const padding = 20 * 60 * 1000;
      return {
        domainStart: minTime - padding,
        domainEnd: maxTime + padding
      };
    },
    buildIntervalsFromItems(items, categoryIndexMap) {
      const intervals = [];
      // 변경: 전체 카테고리 인덱스 맵을 사용해 intervals 생성
      (Array.isArray(items) ? items : []).forEach((item, index) => {
        if (!item) return;
        const eqpId = item.eqpId ?? 'EQP-UNKNOWN';
        const categoryIndex = categoryIndexMap && categoryIndexMap.get ? categoryIndexMap.get(eqpId) : null;
        if (categoryIndex == null) return;

        const start = this.toTimeValue(item.lotStart);
        const end = this.toTimeValue(item.lotFinish);
        if (start == null || end == null || end <= start) return;

        const itemColor = this.resolveColor(item);
        const tooltipText = this.buildTooltipText(item, itemColor);
        const raw = {
          ...item,
          itemColor,
          tooltipText
        };

        intervals.push({
          id: `erlog-${categoryIndex}-${index}`,
          raw,
          itemStyle: { color: itemColor },
          value: [categoryIndex, start, end, Math.max(0, end - start)]
        });
      });
      return intervals;
    },
    normalizeZoomState(next, domain) {
      const domainStart =
        domain && typeof domain.domainStart === 'number' ? domain.domainStart : Date.now();
      const domainEnd =
        domain && typeof domain.domainEnd === 'number' ? domain.domainEnd : domainStart;
      const viewStart = this.clampTime(next && next.viewStart, domainStart, domainEnd, domainStart);
      const viewEnd = this.clampTime(next && next.viewEnd, domainStart, domainEnd, domainEnd);
      const cursorStart = this.clampTime(next && next.cursorStart, viewStart, viewEnd, null);
      const cursorEnd = this.clampTime(next && next.cursorEnd, viewStart, viewEnd, null);

      return {
        viewStart: Math.min(viewStart, viewEnd),
        viewEnd: Math.max(viewStart, viewEnd),
        cursorStart,
        cursorEnd
      };
    },
    clampTime(value, min, max, fallback) {
      if (typeof value !== 'number' || Number.isNaN(value)) return fallback;
      return Math.min(max, Math.max(min, value));
    },
    ensureZoomHasVisibleData(intervals, zoom, domain) {
      // 변경: 현재 줌 범위에 데이터가 없으면 전체 도메인으로 복구
      if (!Array.isArray(intervals) || intervals.length === 0) return null;
      if (!zoom || typeof zoom.viewStart !== 'number' || typeof zoom.viewEnd !== 'number') return null;

      const viewStart = Math.min(zoom.viewStart, zoom.viewEnd);
      const viewEnd = Math.max(zoom.viewStart, zoom.viewEnd);
      const hasVisible = intervals.some((item) => {
        if (!item || !Array.isArray(item.value)) return false;
        const start = this.toTimeValue(item.value[1]);
        const end = this.toTimeValue(item.value[2]);
        if (start == null || end == null) return false;
        return end >= viewStart && start <= viewEnd;
      });

      if (hasVisible) return null;
      if (!domain || typeof domain.domainStart !== 'number' || typeof domain.domainEnd !== 'number') {
        return null;
      }

      return {
        viewStart: domain.domainStart,
        viewEnd: domain.domainEnd,
        cursorStart: null,
        cursorEnd: null
      };
    },
    // 변경 끝: 전체 데이터 기반 카테고리/도메인/intervals
    resolveColor(item) {
      const status = this.resolveStatus(item);
      if (status === 'reject') {
        return COLOR_RULES.reject;
      }
      if (status === 'hasSy') {
        return COLOR_RULES.hasSy;
      }
      return COLOR_RULES.incompleteSy;
    },
    buildTooltipText(item, color) {
      const textColor = TOOLTIP_TEXT_COLOR[color] || '#ffffff';
      void textColor;
      return [
        `Lot ID: ${this.safeText(item.lotId)}`,
        `Layer: ${this.safeText(item.layer)}`,
        `Device: ${this.safeText(item.device)}`,
        `Lot Start: ${this.safeText(item.lotStart)}`,
        `Lot Finish: ${this.safeText(item.lotFinish)}`,
        `Lot Size: ${this.safeText(item.lotSize)}`,
        `Reject Wafer: ${this.safeText(item.rejectWafer)}`
      ].join('\n');
    },
    safeText(value) {
      return value == null ? '-' : String(value);
    },
    formatAxisLabel(value) {
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return '';
      return [
        `${this.pad2(date.getMonth() + 1)}-${this.pad2(date.getDate())}`,
        `${this.pad2(date.getHours())}:${this.pad2(date.getMinutes())}`
      ].join(' ');
    },
    pad2(value) {
      return String(value).padStart(2, '0');
    },
    toTimeValue(value) {
      if (value == null) return null;
      if (typeof value === 'number') return value;
      const parsed = this.parseDateTimeMs(value);
      if (parsed != null) return parsed;
      const time = new Date(value).getTime();
      return Number.isNaN(time) ? null : time;
    },
    parseDateTimeMs(value) {
      const match = /^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})\.(\d{3})$/.exec(
        String(value || '').trim()
      );
      if (!match) return null;
      const [, year, month, day, hour, minute, second, ms] = match;
      const date = new Date(
        Number(year),
        Number(month) - 1,
        Number(day),
        Number(hour),
        Number(minute),
        Number(second),
        Number(ms)
      );
      return Number.isNaN(date.getTime()) ? null : date.getTime();
    }
  }
};
</script>

<style scoped>
.erlog-chart-wrap {
  width: 100%;
  height: 220px;
}

.erlog-chart {
  width: 100%;
  height: 100%;
}
</style>
