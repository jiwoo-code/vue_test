<template>
  <div class="sy-chart-wrap">
    <div class="sy-chart" ref="chart"></div>

    <!-- 상단 슬라이드 -->
    <div
      v-if="topSliderRange.visible"
      class="sy-top-slider-range"
      :style="{
        left: `${topSliderRange.x}px`,
        top: `${topSliderRange.y}px`,
        maxWidth: `${topSliderRange.maxWidth}px`
      }"
      :title="topSliderRange.text"
    >
      {{ topSliderRange.text }}
    </div>

    <div class="sy-marker-overlay">
      <button
        v-for="item in markerButtons"
        :key="item.id"
        class="sy-marker-btn"
        type="button"
        :style="{ left: `${item.x}px`, top: `${item.y}px` }"
        @mouseenter="onMarkerButtonMouseEnter"
        @mouseleave="onMarkerButtonMouseLeave"
        @click="$emit('remove-marker', item.id)"
      >
        x
      </button>
    </div>
  </div>
</template>

<script>
import * as echarts from 'echarts';

// =====================
// 스타일 / 레이아웃 상수
// =====================

const CHART_STYLE = Object.freeze({
  axis: {
    labelColor: '#475569',
    lineColor: '#cbd5e1',
    splitLineColor: '#e2e8f0'
  },
  line: {
    selection: { width: 2, color: '#f97316', type: 'solid' },
    marker: { width: 2, color: '#2563eb', type: 'dashed' },
    markerLabel: { width: 1, color: 'rgba(37, 99, 235, 0.02)', type: 'dashed' },
    cursor: { width: 2, color: '#ef4444', type: 'solid' }
  },
  markerLabel: {
    padding: [2, 6],
    fontSize: 12,
    fontFamily: 'sans-serif',
    borderWidth: 1,
    distance: 6,
    offsetY: -4,
    position: 'start',
    align: 'left',
    verticalAlign: 'bottom',
    rotate: 18,
    color: '#1d4ed8',
    backgroundColor: 'rgba(37, 99, 235, 0.12)',
    borderColor: 'rgba(37, 99, 235, 0.35)'
  }
});

const LAYOUT = Object.freeze({
  grid: { left: 110, right: 62, bottom: 124 },
  slider: { top: 16, height: 22, gap: 6, labelGap: 52, bottom: 18, bottomHeight: 22 }
});

const GRID_INDEX = Object.freeze({
  main: 0,
  pinned: 1,
  label: 2,
  cursor: 3
});

const AXIS_INDEX = Object.freeze({
  main: 0,
  pinned: 1,
  label: 2,
  cursor: 3,
  slider: 4
});

const MARKER_BUTTON = Object.freeze({
  radius: 10,
  offsetX: 0,
  offsetY: 0
});

export default {
  name: 'SyTimelineChart',

  props: {
    markers: { type: Array, default: () => [] },
    timelineData: { type: Object, default: () => ({}) }
  },

  data() {
    return {
      chart: null,

      markerButtons: [],
      markerButtonsRafId: null,

      topSliderRange: {
        visible: false,
        text: '',
        x: 0,
        y: 0,
        maxWidth: 0
      },
      topSliderRangeRafId: null,
      topSliderRangeTextCache: '',
      lastTopRangeSignature: '',

      categories: [],
      pinnedCategory: null,
      scrollCategories: [],
      pinnedIntervals: [],
      scrollIntervals: [],

      selectedCategoryIndex: null,
      domainStart: 0,
      domainEnd: 0,
      viewStart: 0,
      viewEnd: 0,
      cursorStart: 0,
      cursorEnd: 0,

      isSyncingTopSlider: false,

      activeMarkerId: null,
      hoverMarkerId: null,
      hoverClearTimerId: null,
      isHoveringMarkerButton: false
    };
  },

  computed: {
    cursorRange() {
      const topMin = this.viewStart != null ? this.viewStart : this.domainStart;
      const topMax = this.viewEnd != null ? this.viewEnd : this.domainEnd;

      const startRaw = Math.min(this.cursorStart, this.cursorEnd);
      const endRaw = Math.max(this.cursorStart, this.cursorEnd);

      return {
        topMin,
        topMax,
        start: this.clamp(startRaw, topMin, topMax),
        end: this.clamp(endRaw, topMin, topMax)
      };
    },

    markersSignature() {
      const markers = Array.isArray(this.markers) ? this.markers : [];
      return markers
        .map((marker) => {
          const markerId = marker ? marker.id : '';
          const markerTime = marker ? this.toTimeValue(marker.time) : '';
          return `${markerId}:${markerTime}`;
        })
        .join('|');
    }
  },

  watch: {
    markersSignature() {
      this.ensureActiveMarkerIsValid();
      this.updateMarkerLines();
      this.scheduleMarkerButtonsUpdate();
    },

    timelineData: {
      deep: true,
      immediate: true,
      handler(payload) {
        this.applyData(payload);
        this.refreshChart();
      }
    }
  },

  mounted() {
    this.initChart();
    window.addEventListener('resize', this.resizeChart, { passive: true });
  },

  beforeDestroy() {
    window.removeEventListener('resize', this.resizeChart);
    this.teardownChart();
  },

  methods: {
    // =====================
    // 데이터 초기화
    // =====================

    /**
     * payload를 내부 상태로 정규화
     * @param {Object} payload 원본 데이터
     */
    applyData(payload) {
      const safePayload = payload && typeof payload === 'object' ? payload : {};

      const categories = Array.isArray(safePayload.categories) ? safePayload.categories : [];
      const intervals = Array.isArray(safePayload.intervals) ? safePayload.intervals : [];

      const domain = this.resolveDomain(safePayload, intervals);
      const span = domain.end - domain.start;

      this.categories = categories;
      this.pinnedCategory = categories.length ? categories[0] : null;
      this.scrollCategories = categories.slice(1);

      this.pinnedIntervals = intervals
        .filter((item) => item && item.value && item.value[0] === 0)
        .map((item) => ({
          ...item,
          value: [0, item.value[1], item.value[2], item.value[3]]
        }));

      this.scrollIntervals = intervals
        .filter((item) => item && item.value && item.value[0] > 0)
        .map((item) => ({
          ...item,
          value: [item.value[0] - 1, item.value[1], item.value[2], item.value[3]]
        }));

      this.selectedCategoryIndex =
        typeof safePayload.selectedCategoryIndex === 'number'
          ? safePayload.selectedCategoryIndex
          : null;

      this.domainStart = domain.start;
      this.domainEnd = domain.end;

      const defaults = this.getDefaultRanges(domain.start, span);

      this.viewStart = this.normalizeTime(safePayload.viewStart, defaults.viewStart);
      this.viewEnd = this.normalizeTime(safePayload.viewEnd, defaults.viewEnd);
      this.cursorStart = this.normalizeTime(safePayload.cursorStart, defaults.cursorStart);
      this.cursorEnd = this.normalizeTime(safePayload.cursorEnd, defaults.cursorEnd);
    },

    /**
     * 기본 view / cursor 범위 계산
     * @param {number} start domain 시작
     * @param {number} span domain 범위
     * @returns {Object} 기본 range 집합
     */
    getDefaultRanges(start, span) {
      if (!span || span <= 0) {
        return { viewStart: start, viewEnd: start, cursorStart: start, cursorEnd: start };
      }

      return {
        viewStart: start + span * 0.22,
        viewEnd: start + span * 0.42,
        cursorStart: start + span * 0.28,
        cursorEnd: start + span * 0.35
      };
    },

    /**
     * domain 범위 계산
     * @param {Object} payload 입력
     * @param {Array} intervals 인터벌 목록
     * @returns {Object} start/end
     */
    resolveDomain(payload, intervals) {
      const providedStart = this.toTimeValue(payload.domainStart);
      const providedEnd = this.toTimeValue(payload.domainEnd);
      const intervalDomain = this.getIntervalDomain(intervals);

      const start = providedStart != null ? providedStart : intervalDomain.start;
      const end = providedEnd != null ? providedEnd : intervalDomain.end;

      return { start, end: Math.max(end, start) };
    },

    /**
     * intervals 기반 domain 계산
     * @param {Array} intervals 인터벌 목록
     * @returns {Object} start/end
     */
    getIntervalDomain(intervals) {
      let min = null;
      let max = null;

      intervals.forEach((item) => {
        if (!item || !item.value) return;

        const start = this.toTimeValue(item.value[1]);
        const end = this.toTimeValue(item.value[2]);

        if (start != null) min = min == null ? start : Math.min(min, start);
        if (end != null) max = max == null ? end : Math.max(max, end);
      });

      if (min == null || max == null) return { start: 0, end: 0 };
      return { start: min, end: max };
    },

    // =====================
    // 차트 생명주기
    // =====================

    initChart() {
      const element = this.$refs.chart;
      if (!element) return;

      this.chart = echarts.init(element);
      this.chart.setOption(this.buildOption(), { notMerge: true });

      this.applyLayout();
      this.bindChartEvents();

      this.updateMarkerLines();
      this.updateSelectionLines();
      this.updateCursorLines();

      this.scheduleMarkerButtonsUpdate();
      this.syncTopSlider();
      this.requestTopSliderRangeOverlayUpdate({ recalcText: true });
    },

    refreshChart() {
      if (!this.chart) return;

      this.chart.setOption(this.buildOption(), { notMerge: true });

      this.applyLayout();
      this.updateMarkerLines();
      this.updateSelectionLines();
      this.updateCursorLines();

      this.scheduleMarkerButtonsUpdate();
      this.syncTopSlider();

      this.requestTopSliderRangeOverlayUpdate({ recalcText: true });
    },

    teardownChart() {
      if (!this.chart) return;

      this.clearHoverClearTimer();

      if (this.markerButtonsRafId != null) {
        cancelAnimationFrame(this.markerButtonsRafId);
        this.markerButtonsRafId = null;
      }

      if (this.topSliderRangeRafId != null) {
        cancelAnimationFrame(this.topSliderRangeRafId);
        this.topSliderRangeRafId = null;
      }

      this.unbindChartEvents();
      this.chart.dispose();
      this.chart = null;
    },

    resizeChart() {
      if (!this.chart) return;

      this.chart.resize();
      this.applyLayout();
      this.scheduleMarkerButtonsUpdate();
      this.requestTopSliderRangeOverlayUpdate({ recalcText: false });
    },

    // =====================
    // 차트 이벤트
    // =====================

    bindChartEvents() {
      this.chart.on('datazoom', this.onDataZoom);
      this.chart.on('click', this.onChartClick);
      this.chart.on('mouseover', this.onChartMouseOver);
      this.chart.on('mouseout', this.onChartMouseOut);
    },

    unbindChartEvents() {
      this.chart.off('datazoom', this.onDataZoom);
      this.chart.off('click', this.onChartClick);
      this.chart.off('mouseover', this.onChartMouseOver);
      this.chart.off('mouseout', this.onChartMouseOut);
    },

    onChartClick(params) {
      if (!params || params.seriesType !== 'custom') return;
      if (!params.value) return;

      let categoryIndex = null;

      if (params.seriesId === 'sy-bars-pinned') categoryIndex = 0;
      if (params.seriesId === 'sy-bars-main') categoryIndex = params.value[0] + 1;

      if (categoryIndex == null) return;

      this.selectedCategoryIndex = categoryIndex;
      this.updateSelectionLines();
    },

    onChartMouseOver(params) {
      if (params && params.seriesId === 'sy-markers-labels') return;

      const markerId = this.getMarkerIdFromMarkLineEvent(params);
      if (markerId == null) return;

      this.clearHoverClearTimer();
      this.hoverMarkerId = markerId;

      if (this.activeMarkerId !== markerId) {
        this.activeMarkerId = markerId;
        this.scheduleMarkerButtonsUpdate();
      }
    },

    onChartMouseOut(params) {
      if (params && params.seriesId === 'sy-markers-labels') return;

      const markerId = this.getMarkerIdFromMarkLineEvent(params);
      if (markerId == null) return;
      if (this.hoverMarkerId !== markerId) return;

      this.hoverMarkerId = null;

      if (!this.isHoveringMarkerButton) {
        this.scheduleClearActiveMarkerAfterDelay();
      }
    },

    onDataZoom(event) {
      const batches =
        event && Array.isArray(event.batch) && event.batch.length
          ? event.batch
          : event
            ? [event]
            : [];

      if (!batches.length) return;

      let cursorUpdated = false;
      let viewUpdated = false;

      const topMin = this.cursorRange.topMin;
      const topMax = this.cursorRange.topMax;

      batches.forEach((batch) => {
        const zoomId = this.getDataZoomId(batch);

        if (zoomId === 'dz_y') return;

        if (zoomId === 'dz_top') {
          if (this.isSyncingTopSlider) return;

          const zoom = this.getZoomFromEvent(
            { batch: [batch] },
            {
              axisMin: topMin,
              axisMax: topMax,
              fallbackStart: this.cursorStart,
              fallbackEnd: this.cursorEnd
            }
          );

          this.cursorStart = zoom.start;
          this.cursorEnd = zoom.end;
          cursorUpdated = true;
          return;
        }

        const viewZoom = this.getZoomFromEvent(
          { batch: [batch] },
          {
            axisMin: this.domainStart,
            axisMax: this.domainEnd,
            fallbackStart: this.viewStart,
            fallbackEnd: this.viewEnd
          }
        );

        this.viewStart = viewZoom.start;
        this.viewEnd = viewZoom.end;
        viewUpdated = true;
      });

      if (cursorUpdated) {
        this.updateCursorLines();
        this.requestTopSliderRangeOverlayUpdate({ recalcText: true });
      }

      if (viewUpdated) {
        this.syncTopSlider();
        this.requestTopSliderRangeOverlayUpdate({ recalcText: false });
      }

      if (cursorUpdated || viewUpdated) {
        this.scheduleMarkerButtonsUpdate();
      }
    },

    // =====================
    // 마커 버튼 hover 처리
    // =====================

    onMarkerButtonMouseEnter() {
      this.isHoveringMarkerButton = true;
      this.clearHoverClearTimer();
    },

    onMarkerButtonMouseLeave() {
      this.isHoveringMarkerButton = false;

      if (this.hoverMarkerId == null) {
        this.scheduleClearActiveMarkerAfterDelay();
      }
    },

    scheduleClearActiveMarkerAfterDelay() {
      this.clearHoverClearTimer();

      this.hoverClearTimerId = setTimeout(() => {
        if (this.hoverMarkerId == null && !this.isHoveringMarkerButton) {
          this.clearActiveMarker();
        }
      }, 40);
    },

    clearHoverClearTimer() {
      if (this.hoverClearTimerId != null) {
        clearTimeout(this.hoverClearTimerId);
        this.hoverClearTimerId = null;
      }
    },

    clearActiveMarker() {
      this.activeMarkerId = null;
      this.hoverMarkerId = null;
      this.isHoveringMarkerButton = false;
      this.scheduleMarkerButtonsUpdate();
    },

    ensureActiveMarkerIsValid() {
      if (this.activeMarkerId == null) return;

      const markers = Array.isArray(this.markers) ? this.markers : [];
      const exists = markers.some((marker) => marker && marker.id === this.activeMarkerId);

      if (!exists) {
        this.clearHoverClearTimer();
        this.activeMarkerId = null;
        this.hoverMarkerId = null;
        this.isHoveringMarkerButton = false;
        this.markerButtons = [];
      }
    },

    getMarkerIdFromMarkLineEvent(params) {
      if (!params || params.componentType !== 'markLine') return null;
      const data = params.data;
      return data && data.markerId != null ? data.markerId : null;
    },

    // =====================
    // 마커 버튼 위치 계산
    // =====================

    /**
     * datazoom/resize에서 반복 호출이 많아 예약 실행으로 묶음
     * - 연속 이벤트에서 중복 계산을 줄이기 위함
     */
    scheduleMarkerButtonsUpdate() {
      if (this.markerButtonsRafId != null) return;

      this.markerButtonsRafId = requestAnimationFrame(() => {
        this.markerButtonsRafId = null;
        this.updateMarkerButtons();
      });
    },

    updateMarkerButtons() {
      if (!this.chart || this.activeMarkerId == null) {
        this.markerButtons = [];
        return;
      }

      const markers = Array.isArray(this.markers) ? this.markers : [];
      const activeMarker = markers.find((marker) => marker && marker.id === this.activeMarkerId);

      if (!activeMarker) {
        this.markerButtons = [];
        return;
      }

      const mainGridRect = this.getGridRect(GRID_INDEX.main);
      const pinnedGridRect = this.getGridRect(GRID_INDEX.pinned);

      if (!mainGridRect) {
        this.markerButtons = [];
        return;
      }

      const gridRects = [mainGridRect, pinnedGridRect].filter((rect) => rect && rect.height > 0);
      if (!gridRects.length) {
        this.markerButtons = [];
        return;
      }

      const minTop = Math.min(...gridRects.map((rect) => rect.y));
      const maxBottom = Math.max(...gridRects.map((rect) => rect.y + rect.height));
      const lineCenterY = (minTop + maxBottom) / 2;

      const markerTime = this.toTimeValue(activeMarker.time);
      if (markerTime == null) {
        this.markerButtons = [];
        return;
      }

      const lineX = this.getAxisPixelFromValue(markerTime, AXIS_INDEX.main);
      if (lineX == null || Number.isNaN(lineX)) {
        this.markerButtons = [];
        return;
      }

      if (lineX < mainGridRect.x || lineX > mainGridRect.x + mainGridRect.width) {
        this.markerButtons = [];
        return;
      }

      const chartWidth = this.chart.getWidth();
      const chartHeight = this.chart.getHeight();

      const leftBound = MARKER_BUTTON.radius;
      const rightBound = chartWidth - MARKER_BUTTON.radius;
      const topBound = MARKER_BUTTON.radius;
      const bottomBound = chartHeight - MARKER_BUTTON.radius;

      const rawX = lineX + MARKER_BUTTON.offsetX;
      const rawY = lineCenterY + MARKER_BUTTON.offsetY;

      this.markerButtons = [
        {
          id: activeMarker.id,
          x: this.clamp(rawX, leftBound, rightBound),
          y: this.clamp(rawY, topBound, bottomBound)
        }
      ];
    },

    // =====================
    // 레이아웃
    // =====================

    getLayoutMetrics() {
      const chartHeight = this.chart ? this.chart.getHeight() : 640;
      const totalCategories = Math.max(this.categories.length, 1);

      const sliderBottom = LAYOUT.slider.top + LAYOUT.slider.height + LAYOUT.slider.gap;
      const labelHeight = Math.max(0, LAYOUT.slider.labelGap);

      const usableHeight = Math.max(
        0,
        chartHeight - LAYOUT.grid.bottom - sliderBottom - labelHeight
      );

      const rowHeight = totalCategories ? usableHeight / totalCategories : usableHeight;

      return {
        sliderBottom,
        gridBottom: LAYOUT.grid.bottom,
        labelTop: sliderBottom,
        labelHeight,
        pinnedHeight: rowHeight,
        pinnedTop: sliderBottom + labelHeight,
        mainTop: sliderBottom + labelHeight + rowHeight
      };
    },

    applyLayout() {
      if (!this.chart) return;

      const layout = this.getLayoutMetrics();

      this.chart.setOption({
        grid: this.buildGridOptions(layout),
        dataZoom: [
          { id: 'dz_top', top: LAYOUT.slider.top, height: LAYOUT.slider.height },
          { id: 'dz_bottom', bottom: LAYOUT.slider.bottom, height: LAYOUT.slider.bottomHeight },
          { id: 'dz_y', top: layout.mainTop, bottom: layout.gridBottom }
        ]
      });
    },

    buildGridOptions(layout) {
      return [
        {
          id: 'grid-main',
          top: layout.mainTop,
          bottom: layout.gridBottom,
          left: LAYOUT.grid.left,
          right: LAYOUT.grid.right,
          containLabel: false
        },
        {
          id: 'grid-pinned',
          top: layout.pinnedTop,
          height: layout.pinnedHeight,
          left: LAYOUT.grid.left,
          right: LAYOUT.grid.right,
          containLabel: false
        },
        {
          id: 'grid-label',
          top: layout.labelTop,
          height: layout.labelHeight,
          left: LAYOUT.grid.left,
          right: LAYOUT.grid.right,
          containLabel: false
        },
        {
          id: 'grid-cursor',
          top: layout.sliderBottom,
          bottom: layout.gridBottom,
          left: LAYOUT.grid.left,
          right: LAYOUT.grid.right,
          containLabel: false
        }
      ];
    },

    // =====================
    // 옵션 빌더
    // =====================

    buildOption() {
      const layout = this.getLayoutMetrics();

      return {
        backgroundColor: '#ffffff',
        animation: false,
        tooltip: { show: false },
        dataZoom: this.buildDataZoomOptions(layout),
        grid: this.buildGridOptions(layout),
        xAxis: this.buildXAxisOptions(),
        yAxis: this.buildYAxisOptions(),
        series: this.buildSeriesOptions()
      };
    },

    buildDataZoomOptions(layout) {
      return [
        {
          id: 'dz_top',
          type: 'slider',
          xAxisIndex: AXIS_INDEX.slider,
          filterMode: 'weakFilter',
          showDataShadow: false,
          brushSelect: false,
          top: LAYOUT.slider.top,
          height: LAYOUT.slider.height,
          labelFormatter: '',
          startValue: this.cursorRange.start,
          endValue: this.cursorRange.end
        },
        {
          id: 'dz_bottom',
          type: 'slider',
          xAxisIndex: [AXIS_INDEX.main, AXIS_INDEX.pinned],
          filterMode: 'weakFilter',
          showDataShadow: false,
          brushSelect: false,
          bottom: LAYOUT.slider.bottom,
          height: LAYOUT.slider.bottomHeight,
          labelFormatter: '',
          startValue: this.viewStart,
          endValue: this.viewEnd
        },
        {
          id: 'dz_inside',
          type: 'inside',
          xAxisIndex: [AXIS_INDEX.main, AXIS_INDEX.pinned],
          filterMode: 'weakFilter'
        },
        {
          id: 'dz_y',
          type: 'slider',
          yAxisIndex: 0,
          filterMode: 'weakFilter',
          showDataShadow: false,
          right: 8,
          top: layout.mainTop,
          bottom: layout.gridBottom,
          width: 12
        }
      ];
    },

    buildXAxisOptions() {
      const minuteInterval = 60 * 1000;

      return [
        {
          id: 'x-main',
          gridIndex: GRID_INDEX.main,
          type: 'time',
          min: this.domainStart,
          max: this.domainEnd,
          scale: true,
          minInterval: minuteInterval,
          splitNumber: 24,
          axisLine: { lineStyle: { color: CHART_STYLE.axis.lineColor } },
          axisLabel: {
            color: CHART_STYLE.axis.labelColor,
            rotate: 90,
            margin: 6,
            hideOverlap: true,
            interval: 0,
            formatter: (value) => this.formatAxisLabel(value)
          },
          splitLine: { show: true, lineStyle: { color: CHART_STYLE.axis.splitLineColor } }
        },
        this.buildHiddenTimeAxis({
          id: 'x-pinned',
          gridIndex: GRID_INDEX.pinned,
          min: this.domainStart,
          max: this.domainEnd,
          minInterval: minuteInterval,
          splitNumber: 24
        }),
        this.buildHiddenTimeAxis({
          id: 'x-label',
          gridIndex: GRID_INDEX.label,
          min: this.cursorRange.topMin,
          max: this.cursorRange.topMax,
          minInterval: minuteInterval,
          splitNumber: 24
        }),
        this.buildHiddenTimeAxis({
          id: 'x-cursor',
          gridIndex: GRID_INDEX.cursor,
          min: this.cursorRange.topMin,
          max: this.cursorRange.topMax
        }),
        this.buildHiddenTimeAxis({
          id: 'x-slider',
          gridIndex: GRID_INDEX.cursor,
          min: this.cursorRange.topMin,
          max: this.cursorRange.topMax
        })
      ];
    },

    buildYAxisOptions() {
      return [
        this.buildCategoryAxis({
          id: 'y-main',
          gridIndex: GRID_INDEX.main,
          data: this.scrollCategories
        }),
        this.buildCategoryAxis({
          id: 'y-pinned',
          gridIndex: GRID_INDEX.pinned,
          data: this.pinnedCategory ? [this.pinnedCategory] : []
        }),
        this.buildHiddenValueAxis({ id: 'y-label', gridIndex: GRID_INDEX.label, min: 0, max: 1 }),
        this.buildHiddenValueAxis({ id: 'y-cursor', gridIndex: GRID_INDEX.cursor, min: 0, max: 1 })
      ];
    },

    buildSeriesOptions() {
      return [
        this.buildBarSeries({
          id: 'sy-bars-main',
          xAxisIndex: AXIS_INDEX.main,
          yAxisIndex: AXIS_INDEX.main,
          data: this.scrollIntervals
        }),
        this.buildBarSeries({
          id: 'sy-bars-pinned',
          xAxisIndex: AXIS_INDEX.pinned,
          yAxisIndex: AXIS_INDEX.pinned,
          data: this.pinnedIntervals
        }),
        this.buildSelectionSeries({
          id: 'sy-selection-main',
          xAxisIndex: AXIS_INDEX.main,
          yAxisIndex: AXIS_INDEX.main
        }),
        this.buildSelectionSeries({
          id: 'sy-selection-pinned',
          xAxisIndex: AXIS_INDEX.pinned,
          yAxisIndex: AXIS_INDEX.pinned
        }),
        this.buildMarkerLineSeries({
          id: 'sy-markers-main',
          xAxisIndex: AXIS_INDEX.main,
          yAxisIndex: AXIS_INDEX.main,
          silent: false
        }),
        this.buildMarkerLineSeries({
          id: 'sy-markers-pinned-lines',
          xAxisIndex: AXIS_INDEX.pinned,
          yAxisIndex: AXIS_INDEX.pinned,
          silent: true
        }),
        this.buildMarkerLabelSeries(),
        this.buildCursorOverlaySeries()
      ];
    },

    buildBarSeries(options) {
      return {
        id: options.id,
        type: 'custom',
        renderItem: this.renderItem,
        xAxisIndex: options.xAxisIndex,
        yAxisIndex: options.yAxisIndex,
        itemStyle: { opacity: 0.85 },
        encode: { x: [1, 2], y: 0 },
        data: options.data
      };
    },

    buildSelectionSeries(options) {
      return {
        id: options.id,
        type: 'scatter',
        xAxisIndex: options.xAxisIndex,
        yAxisIndex: options.yAxisIndex,
        data: [],
        silent: true,
        markLine: {
          symbol: ['none', 'none'],
          z: 18,
          lineStyle: { ...CHART_STYLE.line.selection },
          label: { show: false },
          data: []
        }
      };
    },

    buildMarkerLineSeries(options) {
      return {
        id: options.id,
        type: 'scatter',
        xAxisIndex: options.xAxisIndex,
        yAxisIndex: options.yAxisIndex,
        data: [],
        silent: options.silent,
        emphasis: { disabled: true },
        markLine: {
          symbol: ['none', 'none'],
          precision: 0,
          z: 20,
          lineStyle: { ...CHART_STYLE.line.marker },
          emphasis: { disabled: true },
          label: { show: false },
          data: []
        }
      };
    },

    buildMarkerLabelSeries() {
      return {
        id: 'sy-markers-labels',
        type: 'scatter',
        xAxisIndex: AXIS_INDEX.label,
        yAxisIndex: AXIS_INDEX.label,
        data: [],
        silent: false,
        emphasis: { disabled: true },
        markLine: {
          symbol: ['none', 'none'],
          precision: 0,
          z: 22,
          lineStyle: { ...CHART_STYLE.line.markerLabel },
          emphasis: { disabled: true },
          label: {
            show: true,
            position: CHART_STYLE.markerLabel.position,
            align: CHART_STYLE.markerLabel.align,
            verticalAlign: CHART_STYLE.markerLabel.verticalAlign,
            distance: CHART_STYLE.markerLabel.distance,
            offset: [0, CHART_STYLE.markerLabel.offsetY],
            rotate: CHART_STYLE.markerLabel.rotate,
            color: CHART_STYLE.markerLabel.color,
            backgroundColor: CHART_STYLE.markerLabel.backgroundColor,
            borderColor: CHART_STYLE.markerLabel.borderColor,
            borderWidth: CHART_STYLE.markerLabel.borderWidth,
            padding: CHART_STYLE.markerLabel.padding,
            borderRadius: 6,
            fontSize: CHART_STYLE.markerLabel.fontSize,
            fontFamily: CHART_STYLE.markerLabel.fontFamily,
            formatter: (params) => {
              const data = params ? params.data : null;
              const value = data ? data.xAxis : null;
              return this.formatDateTime(value);
            }
          },
          data: []
        }
      };
    },

    buildCursorOverlaySeries() {
      return {
        id: 'sy-cursors-overlay',
        type: 'scatter',
        xAxisIndex: AXIS_INDEX.cursor,
        yAxisIndex: AXIS_INDEX.cursor,
        data: [],
        silent: true,
        markLine: {
          symbol: ['none', 'none'],
          z: 15,
          lineStyle: { ...CHART_STYLE.line.cursor },
          label: { show: false },
          data: [{ xAxis: this.cursorRange.start }, { xAxis: this.cursorRange.end }]
        }
      };
    },

    buildHiddenTimeAxis(options) {
      const axis = {
        id: options.id,
        gridIndex: options.gridIndex,
        type: 'time',
        min: options.min,
        max: options.max,
        scale: true,
        show: false,
        axisLine: { show: false },
        axisTick: { show: false },
        axisLabel: { show: false },
        splitLine: { show: false }
      };

      if (options.minInterval != null) axis.minInterval = options.minInterval;
      if (options.splitNumber != null) axis.splitNumber = options.splitNumber;

      return axis;
    },

    buildHiddenValueAxis(options) {
      return {
        id: options.id,
        gridIndex: options.gridIndex,
        type: 'value',
        min: options.min,
        max: options.max,
        axisLine: { show: false },
        axisTick: { show: false },
        axisLabel: { show: false },
        splitLine: { show: false }
      };
    },

    buildCategoryAxis(options) {
      return {
        id: options.id,
        gridIndex: options.gridIndex,
        type: 'category',
        inverse: true,
        data: options.data,
        axisTick: { show: false },
        axisLine: { show: false },
        axisLabel: { color: CHART_STYLE.axis.labelColor }
      };
    },

    renderItem(params, api) {
      const categoryIndex = api.value(0);
      const start = api.coord([api.value(1), categoryIndex]);
      const end = api.coord([api.value(2), categoryIndex]);
      const height = api.size([0, 1])[1] * 0.6;

      const rectShape = echarts.graphic.clipRectByRect(
        { x: start[0], y: start[1] - height / 2, width: end[0] - start[0], height },
        { x: params.coordSys.x, y: params.coordSys.y, width: params.coordSys.width, height: params.coordSys.height }
      );

      return (
        rectShape && {
          type: 'rect',
          transition: ['shape'],
          shape: rectShape,
          style: api.style()
        }
      );
    },

    // =====================
    // 선택 / 마커 업데이트
    // =====================

    updateSelectionLines() {
      if (!this.chart) return;

      const selected = this.selectedCategoryIndex;
      const mainData = [];
      const pinnedData = [];

      if (typeof selected === 'number') {
        if (selected === 0) pinnedData.push({ yAxis: 0 });
        if (selected > 0) mainData.push({ yAxis: selected - 1 });
      }

      this.chart.setOption({
        series: [
          { id: 'sy-selection-main', markLine: { data: mainData } },
          { id: 'sy-selection-pinned', markLine: { data: pinnedData } }
        ]
      });
    },

    updateMarkerLines() {
      if (!this.chart) return;

      const markers = Array.isArray(this.markers) ? this.markers : [];
      const markerLines = markers
        .filter((marker) => marker && marker.time != null)
        .map((marker) => ({ xAxis: marker.time, markerId: marker.id }));

      this.chart.setOption({
        series: [
          { id: 'sy-markers-main', markLine: { data: markerLines } },
          { id: 'sy-markers-pinned-lines', markLine: { data: markerLines } },
          { id: 'sy-markers-labels', markLine: { data: markerLines } }
        ]
      });
    },

    updateCursorLines() {
      if (!this.chart) return;

      this.chart.setOption({
        series: [
          {
            id: 'sy-cursors-overlay',
            markLine: { data: [{ xAxis: this.cursorRange.start }, { xAxis: this.cursorRange.end }] }
          }
        ]
      });
    },

    // =====================
    // 상단 슬라이더 범위 표시
    // =====================

    syncTopSlider() {
      if (!this.chart) return;

      this.isSyncingTopSlider = true;

      this.chart.setOption({
        xAxis: [
          { id: 'x-label', min: this.cursorRange.topMin, max: this.cursorRange.topMax },
          { id: 'x-cursor', min: this.cursorRange.topMin, max: this.cursorRange.topMax },
          { id: 'x-slider', min: this.cursorRange.topMin, max: this.cursorRange.topMax }
        ],
        dataZoom: [{ id: 'dz_top', startValue: this.cursorRange.start, endValue: this.cursorRange.end }]
      });

      setTimeout(() => {
        this.isSyncingTopSlider = false;
        this.requestTopSliderRangeOverlayUpdate({ recalcText: false });
      }, 0);
    },

    /**
     * 상단 슬라이더 표시 업데이트(예약 실행)
     * @param {Object} options 옵션
     * @param {boolean} options.recalcText 텍스트 재계산 여부
     */
    requestTopSliderRangeOverlayUpdate(options) {
      if (this.topSliderRangeRafId != null) return;

      const shouldRecalcText = options && options.recalcText === true;

      this.topSliderRangeRafId = requestAnimationFrame(() => {
        this.topSliderRangeRafId = null;
        this.updateTopSliderRangeOverlay({ recalcText: shouldRecalcText });
      });
    },

    /**
     * 상단 슬라이더 활성 범위 표시(텍스트/위치 분리)
     * @param {Object} options 옵션
     * @param {boolean} options.recalcText 텍스트 재계산 여부
     */
    updateTopSliderRangeOverlay(options) {
      if (!this.chart) return;

      const recalcText = options && options.recalcText === true;

      const startPixel = this.getAxisPixelFromValue(this.cursorRange.start, AXIS_INDEX.slider);
      const endPixel = this.getAxisPixelFromValue(this.cursorRange.end, AXIS_INDEX.slider);

      if (startPixel == null || endPixel == null) {
        this.topSliderRange.visible = false;
        return;
      }

      const left = Math.min(startPixel, endPixel);
      const right = Math.max(startPixel, endPixel);
      const width = right - left;

      if (width < 70) {
        this.topSliderRange.visible = false;
        return;
      }

      if (recalcText) {
        const signature = `${this.cursorRange.start}-${this.cursorRange.end}`;

        if (signature !== this.lastTopRangeSignature) {
          this.lastTopRangeSignature = signature;
          this.topSliderRangeTextCache = this.formatRangeMs(Math.abs(this.cursorRange.end - this.cursorRange.start));
        }
      }

      const text = this.topSliderRangeTextCache || this.formatRangeMs(Math.abs(this.cursorRange.end - this.cursorRange.start));

      this.topSliderRange = {
        visible: true,
        text,
        x: (left + right) / 2,
        y: LAYOUT.slider.top + LAYOUT.slider.height / 2,
        maxWidth: Math.max(0, width - 10)
      };
    },

    formatRangeMs(ms) {
      const totalMs = typeof ms === 'number' ? ms : 0;

      const hours = Math.floor(totalMs / 3600000);
      const minutes = Math.floor((totalMs % 3600000) / 60000);
      const seconds = Math.floor((totalMs % 60000) / 1000);
      const millis = totalMs % 1000;

      return `Time: ${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(millis).padStart(3, '0')}`;
    },

    // =====================
    // 자주 쓰이는 공통 함수
    // =====================

    /**
     * ECharts dataZoom 이벤트에서 start/end 추출
     * @param {Object} event 이벤트
     * @param {Object} options 축/기본값 옵션
     * @param {number} options.axisMin 축 최소
     * @param {number} options.axisMax 축 최대
     * @param {number} options.fallbackStart 기본 start
     * @param {number} options.fallbackEnd 기본 end
     * @returns {Object} start/end
     */
    getZoomFromEvent(event, options) {
      const axisMin = options.axisMin;
      const axisMax = options.axisMax;
      const fallbackStart = options.fallbackStart;
      const fallbackEnd = options.fallbackEnd;

      const batch = event && event.batch && event.batch[0] ? event.batch[0] : null;

      if (batch && (batch.startValue != null || batch.endValue != null)) {
        return {
          start: batch.startValue != null ? batch.startValue : fallbackStart,
          end: batch.endValue != null ? batch.endValue : fallbackEnd
        };
      }

      if (batch && (batch.start != null || batch.end != null)) {
        const span = axisMax - axisMin;

        const start =
          batch.start != null && span
            ? axisMin + (span * batch.start) / 100
            : fallbackStart;

        const end =
          batch.end != null && span
            ? axisMin + (span * batch.end) / 100
            : fallbackEnd;

        return { start: Math.round(start), end: Math.round(end) };
      }

      return { start: fallbackStart, end: fallbackEnd };
    },

    getGridRect(gridIndex) {
      if (!this.chart) return null;

      const model = this.chart.getModel();
      const grid = model ? model.getComponent('grid', gridIndex) : null;
      const coord = grid ? grid.coordinateSystem : null;
      const rect = coord && coord.getRect ? coord.getRect() : null;

      if (!rect) return null;
      return { x: rect.x, y: rect.y, width: rect.width, height: rect.height };
    },

    getAxisPixelFromValue(value, axisIndex) {
      if (!this.chart) return null;

      const pixel = this.chart.convertToPixel({ xAxisIndex: axisIndex }, value);
      return Array.isArray(pixel) ? pixel[0] : pixel;
    },

    getDataZoomId(item) {
      if (!item) return null;
      if (item.dataZoomId) return item.dataZoomId;

      if (typeof item.dataZoomIndex === 'number' && this.chart) {
        const option = this.chart.getOption();
        const dataZoom = option ? option.dataZoom : null;
        const zoom = Array.isArray(dataZoom) ? dataZoom[item.dataZoomIndex] : null;
        return zoom && zoom.id ? zoom.id : null;
      }

      return null;
    },

    normalizeTime(value, fallback) {
      const parsed = this.toTimeValue(value);
      return parsed != null ? parsed : fallback;
    },

    clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    },

    toTimeValue(value) {
      if (value == null) return null;
      if (typeof value === 'number') return value;

      if (echarts && echarts.number && typeof echarts.number.parseDate === 'function') {
        const parsed = echarts.number.parseDate(value);
        if (parsed && !Number.isNaN(parsed.getTime())) {
          return parsed.getTime();
        }
      }

      const time = new Date(value).getTime();
      return Number.isNaN(time) ? null : time;
    },

    formatAxisLabel(value) {
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return '';

      const month = this.pad2(date.getMonth() + 1);
      const day = this.pad2(date.getDate());
      const hours = this.pad2(date.getHours());
      const minutes = this.pad2(date.getMinutes());

      return `${month}-${day} ${hours}:${minutes}`;
    },

    formatDateTime(value) {
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return '';

      const year = date.getFullYear();
      const month = this.pad2(date.getMonth() + 1);
      const day = this.pad2(date.getDate());
      const hours = this.pad2(date.getHours());
      const minutes = this.pad2(date.getMinutes());
      const seconds = this.pad2(date.getSeconds());

      return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    },

    pad2(value) {
      return String(value).padStart(2, '0');
    }
  }
};
</script>

<style scoped>
.sy-chart-wrap {
  position: relative;
  width: 100%;
  height: 640px;
  user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
}

.sy-chart {
  width: 100%;
  height: 100%;
  border-radius: 14px;
  overflow: hidden;
  background: #ffffff;
  border: 1px solid rgba(15, 23, 42, 0.12);
}

.sy-top-slider-range {
  position: absolute;
  transform: translate(-50%, -50%);
  pointer-events: none;
  padding: 2px 8px;
  border-radius: 10px;
  background: rgba(15, 23, 42, 0.35);
  color: #ffffff;
  font: 12px sans-serif;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.sy-marker-overlay {
  position: absolute;
  inset: 0;
  pointer-events: none;
  border-radius: 14px;
  overflow: hidden;
}

.sy-marker-btn {
  position: absolute;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, 0.85);
  background: #1d4ed8;
  color: #ffffff;
  font: bold 12px sans-serif;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  cursor: pointer;
  pointer-events: auto;
}
</style>
