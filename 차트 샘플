<template>
  <div class="sy-chart-wrap">
    <div class="sy-chart" ref="chart"></div>

    <!-- 상단 슬라이드 -->
    <div
      v-if="topSliderRange.visible"
      class="sy-top-slider-range"
      :style="{
        left: `${topSliderRange.x}px`,
        top: `${topSliderRange.y}px`,
        maxWidth: `${topSliderRange.maxWidth}px`
      }"
    >
      {{ topSliderRange.text }}
    </div>

    <div class="sy-marker-overlay">
      <button
        v-for="item in markerButtons"
        :key="item.id"
        class="sy-marker-btn"
        type="button"
        :style="{ left: `${item.x}px`, top: `${item.y}px` }"
        @mouseenter="onMarkerButtonMouseEnter"
        @mouseleave="onMarkerButtonMouseLeave"
        @click="$emit('remove-marker', item.id)"
      >
        x
      </button>
    </div>
  </div>
</template>

<script>
import * as echarts from 'echarts';

// =====================
// 스타일 / 레이아웃 상수
// =====================

const LAYOUT = Object.freeze({
  grid: { left: 110, right: 62, bottom: 124 },
  slider: {
    top: 16,
    height: 22,
    gap: 6,
    labelGap: 52,
    bottom: 18,
    bottomHeight: 22
  }
});

const GRID_INDEX = Object.freeze({
  main: 0,
  pinned: 1,
  label: 2,
  cursor: 3
});

const AXIS_INDEX = Object.freeze({
  main: 0,
  pinned: 1,
  label: 2,
  cursor: 3,
  slider: 4
});

const MARKER_BUTTON = Object.freeze({
  radius: 10,
  offsetX: 0,
  offsetY: 0
});

// =====================
// 컴포넌트
// =====================

export default {
  name: 'SyTimelineChart',

  props: {
    markers: { type: Array, default: () => [] },
    timelineData: { type: Object, default: () => ({}) }
  },

  data() {
    return {
      chart: null,

      // 마커 삭제 버튼
      markerButtons: [],
      markerButtonsRafId: null,

      // 상단 슬라이더 범위 표시
      topSliderRange: {
        visible: false,
        text: '',
        x: 0,
        y: 0,
        maxWidth: 0
      },

      // 데이터 상태
      categories: [],
      pinnedCategory: null,
      scrollCategories: [],
      pinnedIntervals: [],
      scrollIntervals: [],

      // 선택 / 범위 상태
      selectedCategoryIndex: null,
      domainStart: 0,
      domainEnd: 0,
      viewStart: 0,
      viewEnd: 0,
      cursorStart: 0,
      cursorEnd: 0,

      // 슬라이더 동기화 플래그
      isSyncingTopSlider: false,

      // 마커 hover 상태
      activeMarkerId: null,
      hoverMarkerId: null,
      hoverClearTimerId: null,
      isHoveringMarkerButton: false
    };
  },

  computed: {
    cursorRange() {
      const topMin = this.viewStart ?? this.domainStart;
      const topMax = this.viewEnd ?? this.domainEnd;

      const startRaw = Math.min(this.cursorStart, this.cursorEnd);
      const endRaw = Math.max(this.cursorStart, this.cursorEnd);

      return {
        topMin,
        topMax,
        start: this.clamp(startRaw, topMin, topMax),
        end: this.clamp(endRaw, topMin, topMax)
      };
    },

    // deep watch 대신 사용하는 시그니처
    markersSignature() {
      return this.markers
        .map((m) => `${m?.id}:${this.toTimeValue(m?.time)}`)
        .join('|');
    }
  },

  watch: {
    markersSignature() {
      this.ensureActiveMarkerIsValid();
      this.updateMarkerLines();
      this.scheduleMarkerButtonsUpdate();
    },

    timelineData: {
      deep: true,
      immediate: true,
      handler(payload) {
        this.applyData(payload);
        this.refreshChart();
      }
    }
  },

  mounted() {
    this.initChart();
    window.addEventListener('resize', this.resizeChart, { passive: true });
  },

  beforeDestroy() {
    window.removeEventListener('resize', this.resizeChart);
    this.teardownChart();
  },

  methods: {
    // =====================
    // 데이터 초기화
    // =====================

    /**
     * payload를 내부 상태로 정규화
     */
    applyData(payload = {}) {
      const categories = Array.isArray(payload.categories) ? payload.categories : [];
      const intervals = Array.isArray(payload.intervals) ? payload.intervals : [];

      const domain = this.resolveDomain(payload, intervals);
      const span = domain.end - domain.start;

      this.categories = categories;
      this.pinnedCategory = categories[0] ?? null;
      this.scrollCategories = categories.slice(1);

      // pinned / scroll 인터벌 분리
      this.pinnedIntervals = intervals
        .filter((item) => item?.value?.[0] === 0)
        .map((item) => ({
          ...item,
          value: [0, item.value[1], item.value[2], item.value[3]]
        }));

      this.scrollIntervals = intervals
        .filter((item) => item?.value?.[0] > 0)
        .map((item) => ({
          ...item,
          value: [item.value[0] - 1, item.value[1], item.value[2], item.value[3]]
        }));

      this.selectedCategoryIndex = payload.selectedCategoryIndex ?? null;

      this.domainStart = domain.start;
      this.domainEnd = domain.end;

      const defaults = this.getDefaultRanges(domain.start, span);

      this.viewStart = this.normalizeTime(payload.viewStart, defaults.viewStart);
      this.viewEnd = this.normalizeTime(payload.viewEnd, defaults.viewEnd);
      this.cursorStart = this.normalizeTime(payload.cursorStart, defaults.cursorStart);
      this.cursorEnd = this.normalizeTime(payload.cursorEnd, defaults.cursorEnd);
    },

    /**
     * 기본 view / cursor 범위 계산
     */
    getDefaultRanges(start, span) {
      if (span <= 0) {
        return {
          viewStart: start,
          viewEnd: start,
          cursorStart: start,
          cursorEnd: start
        };
      }

      return {
        viewStart: start + span * 0.22,
        viewEnd: start + span * 0.42,
        cursorStart: start + span * 0.28,
        cursorEnd: start + span * 0.35
      };
    },

    /**
     * domain 범위 계산
     */
    resolveDomain(payload, intervals) {
      const providedStart = this.toTimeValue(payload.domainStart);
      const providedEnd = this.toTimeValue(payload.domainEnd);
      const intervalDomain = this.getIntervalDomain(intervals);

      const start = providedStart ?? intervalDomain.start;
      const end = providedEnd ?? intervalDomain.end;

      return { start, end: Math.max(end, start) };
    },

    getIntervalDomain(intervals) {
      let min = null;
      let max = null;

      intervals.forEach((item) => {
        if (!item?.value) return;

        const start = this.toTimeValue(item.value[1]);
        const end = this.toTimeValue(item.value[2]);

        if (start != null) min = min == null ? start : Math.min(min, start);
        if (end != null) max = max == null ? end : Math.max(max, end);
      });

      return min == null || max == null ? { start: 0, end: 0 } : { start: min, end: max };
    },

    // =====================
    // 차트 생명주기
    // =====================

    initChart() {
      const el = this.$refs.chart;
      if (!el) return;

      this.chart = echarts.init(el);
      this.chart.setOption(this.buildOption(), { notMerge: true });

      this.applyLayout();
      this.bindChartEvents();

      this.updateMarkerLines();
      this.updateSelectionLines();
      this.updateCursorLines();

      this.scheduleMarkerButtonsUpdate();
      this.syncTopSlider();
      this.updateTopSliderRangeOverlay();
    },

    refreshChart() {
      if (!this.chart) return;

      this.chart.setOption(this.buildOption(), { notMerge: true });

      this.applyLayout();
      this.updateMarkerLines();
      this.updateSelectionLines();
      this.updateCursorLines();

      this.scheduleMarkerButtonsUpdate();
      this.syncTopSlider();
      this.updateTopSliderRangeOverlay();
    },

    teardownChart() {
      if (!this.chart) return;

      this.clearHoverClearTimer();

      if (this.markerButtonsRafId != null) {
        cancelAnimationFrame(this.markerButtonsRafId);
        this.markerButtonsRafId = null;
      }

      this.unbindChartEvents();
      this.chart.dispose();
      this.chart = null;
    },

    resizeChart() {
      if (!this.chart) return;

      this.chart.resize();
      this.applyLayout();
      this.scheduleMarkerButtonsUpdate();
      this.updateTopSliderRangeOverlay();
    },

    // =====================
    // 차트 이벤트
    // =====================

    bindChartEvents() {
      this.chart.on('datazoom', this.onDataZoom);
      this.chart.on('click', this.onChartClick);
      this.chart.on('mouseover', this.onChartMouseOver);
      this.chart.on('mouseout', this.onChartMouseOut);
    },

    unbindChartEvents() {
      this.chart.off('datazoom', this.onDataZoom);
      this.chart.off('click', this.onChartClick);
      this.chart.off('mouseover', this.onChartMouseOver);
      this.chart.off('mouseout', this.onChartMouseOut);
    },

    onChartClick(params) {
      if (params?.seriesType !== 'custom') return;

      const categoryIndex =
        params.seriesId === 'sy-bars-pinned'
          ? 0
          : params.seriesId === 'sy-bars-main'
            ? params.value?.[0] + 1
            : null;

      if (categoryIndex == null) return;

      this.selectedCategoryIndex = categoryIndex;
      this.updateSelectionLines();
    },

    onChartMouseOver(params) {
      // 라벨 제외
      if (params?.seriesId === 'sy-markers-labels') return;

      const markerId = this.getMarkerIdFromMarkLineEvent(params);
      if (markerId == null) return;

      this.clearHoverClearTimer();
      this.hoverMarkerId = markerId;

      if (this.activeMarkerId !== markerId) {
        this.activeMarkerId = markerId;
        this.scheduleMarkerButtonsUpdate();
      }
    },

    onChartMouseOut(params) {
      if (params?.seriesId === 'sy-markers-labels') return;

      const markerId = this.getMarkerIdFromMarkLineEvent(params);
      if (markerId == null || this.hoverMarkerId !== markerId) return;

      this.hoverMarkerId = null;

      if (!this.isHoveringMarkerButton) {
        this.scheduleClearActiveMarkerAfterDelay();
      }
    },

    onDataZoom(event) {
      const batches = Array.isArray(event?.batch) ? event.batch : [event];

      let cursorUpdated = false;
      let viewUpdated = false;

      batches.forEach((batch) => {
        const zoomId = this.getDataZoomId(batch);

        if (zoomId === 'dz_top' && !this.isSyncingTopSlider) {
          const zoom = this.getZoomFromEvent(
            { batch: [batch] },
            {
              axisMin: this.cursorRange.topMin,
              axisMax: this.cursorRange.topMax,
              dataZoomId: 'dz_top',
              fallbackStart: this.cursorStart,
              fallbackEnd: this.cursorEnd
            }
          );

          this.cursorStart = zoom.start;
          this.cursorEnd = zoom.end;
          cursorUpdated = true;
          return;
        }

        if (zoomId !== 'dz_y') {
          const zoom = this.getZoomFromEvent(
            { batch: [batch] },
            {
              axisMin: this.domainStart,
              axisMax: this.domainEnd,
              dataZoomId: zoomId,
              fallbackStart: this.viewStart,
              fallbackEnd: this.viewEnd
            }
          );

          this.viewStart = zoom.start;
          this.viewEnd = zoom.end;
          viewUpdated = true;
        }
      });

      // 변경 반영
      if (cursorUpdated) this.updateCursorLines();
      if (viewUpdated) this.syncTopSlider();

      if (cursorUpdated || viewUpdated) {
        this.scheduleMarkerButtonsUpdate();
        this.updateTopSliderRangeOverlay();
      }
    },

    // =====================
    // 마커 버튼 hover 처리
    // =====================

    onMarkerButtonMouseEnter() {
      this.isHoveringMarkerButton = true;
      this.clearHoverClearTimer();
    },

    onMarkerButtonMouseLeave() {
      this.isHoveringMarkerButton = false;

      if (this.hoverMarkerId == null) {
        this.scheduleClearActiveMarkerAfterDelay();
      }
    },

    scheduleClearActiveMarkerAfterDelay() {
      this.clearHoverClearTimer();

      this.hoverClearTimerId = setTimeout(() => {
        if (this.hoverMarkerId == null && !this.isHoveringMarkerButton) {
          this.clearActiveMarker();
        }
      }, 40);
    },

    clearHoverClearTimer() {
      if (this.hoverClearTimerId != null) {
        clearTimeout(this.hoverClearTimerId);
        this.hoverClearTimerId = null;
      }
    },

    clearActiveMarker() {
      this.activeMarkerId = null;
      this.hoverMarkerId = null;
      this.isHoveringMarkerButton = false;
      this.scheduleMarkerButtonsUpdate();
    },

    ensureActiveMarkerIsValid() {
      if (this.activeMarkerId == null) return;

      const exists = this.markers.some((m) => m?.id === this.activeMarkerId);
      if (!exists) {
        this.clearActiveMarker();
      }
    },

    getMarkerIdFromMarkLineEvent(params) {
      return params?.componentType === 'markLine' ? params.data?.markerId : null;
    },

    // =====================
    // 마커 버튼 위치 계산
    // =====================

    /**
     * dataZoom / resize 시 과도 호출 방지를 위한 예약 실행
     */
    scheduleMarkerButtonsUpdate() {
      if (this.markerButtonsRafId != null) return;

      this.markerButtonsRafId = requestAnimationFrame(() => {
        this.markerButtonsRafId = null;
        this.updateMarkerButtons();
      });
    },

    updateMarkerButtons() {
      if (!this.chart || this.activeMarkerId == null) {
        this.markerButtons = [];
        return;
      }

      const mainGridRect = this.getGridRect(GRID_INDEX.main);
      const pinnedGridRect = this.getGridRect(GRID_INDEX.pinned);
      if (!mainGridRect) return;

      const gridRects = [mainGridRect, pinnedGridRect].filter((r) => r?.height);
      const lineCenterY =
        (Math.min(...gridRects.map((r) => r.y)) +
          Math.max(...gridRects.map((r) => r.y + r.height))) /
        2;

      const marker = this.markers.find((m) => m?.id === this.activeMarkerId);
      if (!marker) return;

      const x = this.getAxisPixelFromValue(this.toTimeValue(marker.time));
      if (x == null) return;

      this.markerButtons = [
        {
          id: marker.id,
          x: this.clamp(x, MARKER_BUTTON.radius, this.chart.getWidth() - MARKER_BUTTON.radius),
          y: this.clamp(
            lineCenterY,
            MARKER_BUTTON.radius,
            this.chart.getHeight() - MARKER_BUTTON.radius
          )
        }
      ];
    },

    // =====================
    // 상단 슬라이더 범위 표시
    // =====================

    syncTopSlider() {
      this.isSyncingTopSlider = true;

      this.chart.setOption({
        xAxis: [
          { id: 'x-label', min: this.cursorRange.topMin, max: this.cursorRange.topMax },
          { id: 'x-cursor', min: this.cursorRange.topMin, max: this.cursorRange.topMax },
          { id: 'x-slider', min: this.cursorRange.topMin, max: this.cursorRange.topMax }
        ],
        dataZoom: [
          { id: 'dz_top', startValue: this.cursorRange.start, endValue: this.cursorRange.end }
        ]
      });

      setTimeout(() => {
        this.isSyncingTopSlider = false;
        this.updateTopSliderRangeOverlay();
      }, 0);
    },

    updateTopSliderRangeOverlay() {
      const startX = this.getAxisPixelFromValue(this.cursorRange.start, AXIS_INDEX.slider);
      const endX = this.getAxisPixelFromValue(this.cursorRange.end, AXIS_INDEX.slider);
      if (startX == null || endX == null) return;

      const left = Math.min(startX, endX);
      const right = Math.max(startX, endX);
      const width = right - left;

      if (width < 70) {
        this.topSliderRange.visible = false;
        return;
      }

      this.topSliderRange = {
        visible: true,
        text: this.formatRangeMs(Math.abs(this.cursorRange.end - this.cursorRange.start)),
        x: (left + right) / 2,
        y: LAYOUT.slider.top + LAYOUT.slider.height / 2,
        maxWidth: width - 10
      };
    },

    formatRangeMs(ms) {
      const h = Math.floor(ms / 3600000);
      const m = Math.floor((ms % 3600000) / 60000);
      const s = Math.floor((ms % 60000) / 1000);
      const msRemain = ms % 1000;

      return `Time: ${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}:${String(
        s
      ).padStart(2, '0')}.${String(msRemain).padStart(3, '0')}`;
    },

    // =====================
    // 공통 유틸
    // =====================

    getAxisPixelFromValue(value, axisIndex = AXIS_INDEX.main) {
      const pixel = this.chart.convertToPixel({ xAxisIndex: axisIndex }, value);
      return Array.isArray(pixel) ? pixel[0] : pixel;
    },

    getGridRect(index) {
      const grid = this.chart.getModel().getComponent('grid', index);
      return grid?.coordinateSystem?.getRect() ?? null;
    },

    getDataZoomId(item) {
      if (item?.dataZoomId) return item.dataZoomId;
      return this.chart?.getOption().dataZoom?.[item?.dataZoomIndex]?.id ?? null;
    },

    getZoomFromEvent(event, options) {
      const batch = event.batch?.[0];
      const span = options.axisMax - options.axisMin;

      if (batch?.startValue != null || batch?.endValue != null) {
        return {
          start: batch.startValue ?? options.fallbackStart,
          end: batch.endValue ?? options.fallbackEnd
        };
      }

      if (batch?.start != null || batch?.end != null) {
        return {
          start: options.axisMin + (span * batch.start) / 100,
          end: options.axisMin + (span * batch.end) / 100
        };
      }

      return {
        start: options.fallbackStart,
        end: options.fallbackEnd
      };
    },

    normalizeTime(value, fallback) {
      return this.toTimeValue(value) ?? fallback;
    },

    clamp(value, min, max) {
      return Math.min(max, Math.max(min, value));
    },

    toTimeValue(value) {
      if (typeof value === 'number') return value;
      const parsed = echarts.number?.parseDate?.(value);
      return parsed?.getTime?.() ?? new Date(value).getTime();
    }
  }
};
</script>

<style scoped>
.sy-chart-wrap {
  position: relative;
  width: 100%;
  height: 640px;
}

.sy-chart {
  width: 100%;
  height: 100%;
  border-radius: 14px;
  border: 1px solid rgba(15, 23, 42, 0.12);
}

.sy-top-slider-range {
  position: absolute;
  transform: translate(-50%, -50%);
  pointer-events: none;
  padding: 2px 8px;
  background: rgba(15, 23, 42, 0.35);
  color: #fff;
  border-radius: 10px;
  font-size: 12px;
}

.sy-marker-overlay {
  position: absolute;
  inset: 0;
  pointer-events: none;
}

.sy-marker-btn {
  position: absolute;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: #1d4ed8;
  color: #fff;
  pointer-events: auto;
}
</style>