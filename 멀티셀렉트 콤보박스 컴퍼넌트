<template>
  <div class="virtual-combo-select">
    <!-- 컨트롤 영역 -->
    <div class="vcs-control" @click.stop="toggleDropdown">
      <span v-if="summaryText" class="vcs-summary">
        {{ summaryText }}
      </span>
      <span v-else class="vcs-summary vcs-placeholder">
        {{ placeholder }}
      </span>

      <!-- 화살표 아이콘 -->
      <i
        class="vcs-arrow-icon"
        :class="{ open: isOpen }"
        :style="arrowIconStyle"
      ></i>
    </div>

    <!-- 드롭다운 -->
    <div v-if="isOpen" class="vcs-dropdown">
      <!-- 검색 영역: searchable = true 일 때만 표시 -->
      <template v-if="searchable">
        <input
          v-model="keyword"
          type="text"
          class="vcs-search-input"
          :placeholder="searchPlaceholder"
          @click.stop
        />
      </template>

      <!-- 멀티일 때만 Select All -->
      <div
        v-if="multiple"
        class="vcs-option-row vcs-select-all-row"
        @click.stop="onSelectAllClick"
      >
        <i
          class="vcs-checkbox"
          :class="selectAllCheckboxClass"
          :style="selectAllCheckboxStyle"
          @click.stop.prevent="onSelectAllClick"
        ></i>

        <span
          class="vcs-option-label"
          :class="selectAllLabelClass"
        >
          전체 선택
        </span>
      </div>

      <!-- 리스트 (가상 스크롤) -->
      <RecycleScroller
        class="vcs-options"
        :items="filteredItems"
        :item-size="ITEM_ROW_HEIGHT"
        key-field="id"
      >
        <template v-slot="{ item }">
          <div
            class="vcs-option-row"
            :class="{ 'is-selected': isChecked(item) }"
            @click.stop="onRowClick(item)"
          >
            <!-- 체크박스 -->
            <i
              class="vcs-checkbox"
              :class="checkboxClassForItem(item)"
              :style="checkboxStyleForItem(item)"
              @click.stop.prevent="onRowClick(item)"
            ></i>

            <!-- 라벨 -->
            <span
              class="vcs-option-label"
              :class="labelClassForItem(item)"
            >
              {{ item.label }}
            </span>
          </div>
        </template>
      </RecycleScroller>
    </div>
  </div>
</template>

<script>
import { RecycleScroller } from 'vue-virtual-scroller'
import 'vue-virtual-scroller/dist/vue-virtual-scroller.css'

/**
 * 컨트롤 영역에 표시할 라벨 개수의 상한
 *  - 초과 시 ", ..." 으로 축약 표현
 */
const MAX_LABEL_COUNT = 7

/**
 * 각 행의 가상 스크롤 기준 높이(px)
 */
const ITEM_ROW_HEIGHT = 28

export default {
  name: 'VirtualComboSelect',
  components: {
    RecycleScroller
  },
  props: {
    /**
     * v-model 값
     *  - multiple = true  : Array
     *  - multiple = false : 단일 값 (id)
     */
    value: {
      type: [Array, String, Number, Object, null],
      default: null
    },
    /**
     * 콤보박스 항목 목록
     *  - [{ id, label }, ...] 형태
     */
    items: {
      type: Array,
      required: true
    },
    /**
     * 멀티 선택 여부
     *  - true  : 멀티 셀렉트
     *  - false : 싱글 셀렉트
     */
    multiple: {
      type: Boolean,
      default: false
    },
    /**
     * 항목 미선택 시 컨트롤 영역에 표시할 플레이스홀더
     */
    placeholder: {
      type: String,
      default: '선택하세요'
    },
    /**
     * 검색 인풋 플레이스홀더
     */
    searchPlaceholder: {
      type: String,
      default: '검색...'
    },
    /**
     * 검색 기능 사용 여부
     *  - true  : 검색 인풋 노출, 필터링 적용
     *  - false : 검색 인풋 숨김, 필터링 미적용
     */
    searchable: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      /**
       * 드롭다운 열림 상태
       */
      isOpen: false,
      /**
       * 검색 키워드
       */
      keyword: '',
      /**
       * 체크박스/화살표 SVG 경로
       *  - webpack의 require를 사용하여 번들링 시 경로를 안전하게 해석
       */
      checkboxCheckedImg: require('@/assets/style/svg/virtual-dropdown/checkbox_checked.svg'),
      checkboxUncheckedImg: require('@/assets/style/svg/virtual-dropdown/checkbox_unchecked.svg'),
      checkboxIndeterminateImg: require('@/assets/style/svg/virtual-dropdown/checkbox_indeterminate.svg'),
      arrowDownImg: require('@/assets/style/svg/virtual-dropdown/arrow_down.svg')
    }
  },
  computed: {
    /**
     * 각 항목 id를 키로 하는 맵을 생성한다.
     *  - id -> item
     * @returns {Object<string, object>}
     */
    itemMap() {
      const map = {}
      const length = this.items.length

      for (let index = 0; index < length; index += 1) {
        const item = this.items[index]
        map[item.id] = item
      }

      return map
    },

    /**
     * 선택된 id를 항상 배열 형태로 정규화한다.
     * @returns {Array<any>}
     */
    normalizedSelectedIds() {
      if (this.multiple) {
        if (Array.isArray(this.value)) {
          return this.value
        }
        return []
      }

      if (this.value === null || this.value === undefined) {
        return []
      }

      return [this.value]
    },

    /**
     * 검색 조건이 반영된 항목 목록을 반환한다.
     *  - searchable = false 이면 원본 items를 그대로 반환한다.
     * @returns {Array<object>}
     */
    filteredItems() {
      if (!this.searchable) {
        return this.items
      }

      const trimmedKeyword = this.keyword.trim()
      if (!trimmedKeyword) {
        return this.items
      }

      const lowerKeyword = trimmedKeyword.toLowerCase()
      return this.items.filter(item => {
        let label = ''

        if (item && item.label !== undefined && item.label !== null) {
          label = String(item.label)
        }

        return label.toLowerCase().indexOf(lowerKeyword) !== -1
      })
    },

    /**
     * 컨트롤 영역에 표시할 요약 텍스트를 반환한다.
     *  - 싱글: 선택된 항목의 라벨
     *  - 멀티: 앞에서부터 최대 MAX_LABEL_COUNT개 라벨을 ", "로 연결, 초과 시 ", ..." 추가
     * @returns {string}
     */
    summaryText() {
      const selectedIds = this.normalizedSelectedIds
      const selectedCount = selectedIds.length

      if (selectedCount === 0) {
        return ''
      }

      // 싱글 모드
      if (!this.multiple) {
        const selectedId = selectedIds[0]
        const item = this.itemMap[selectedId]

        if (item && item.label !== undefined && item.label !== null) {
          return String(item.label)
        }

        return String(selectedId)
      }

      // 멀티 모드
      const labels = []
      const limit = Math.min(selectedCount, MAX_LABEL_COUNT)

      for (let index = 0; index < limit; index += 1) {
        const id = selectedIds[index]
        const item = this.itemMap[id]

        if (item && item.label !== undefined && item.label !== null) {
          labels.push(String(item.label))
        } else {
          labels.push(String(id))
        }
      }

      let text = labels.join(', ')
      if (selectedCount > MAX_LABEL_COUNT) {
        text += ', ...'
      }

      return text
    },

    /**
     * 전체 항목 수를 반환한다.
     * @returns {number}
     */
    totalCount() {
      return this.items.length
    },

    /**
     * 선택된 항목 수를 반환한다.
     * @returns {number}
     */
    selectedCount() {
      return this.normalizedSelectedIds.length
    },

    /**
     * 전체 선택 여부를 판단한다.
     * @returns {boolean}
     */
    isAllSelected() {
      return this.totalCount > 0 && this.selectedCount === this.totalCount
    },

    /**
     * 일부 선택(부분 선택) 상태인지 여부를 판단한다.
     * @returns {boolean}
     */
    isPartiallySelected() {
      return (
        this.selectedCount > 0 &&
        this.selectedCount < this.totalCount
      )
    },

    /**
     * Select All 체크박스에 적용할 클래스명을 반환한다.
     * @returns {string}
     */
    selectAllCheckboxClass() {
      if (this.isAllSelected) {
        return 'is-checked'
      }

      if (this.isPartiallySelected) {
        return 'is-partially-checked'
      }

      return 'is-unchecked'
    },

    /**
     * Select All 라벨에 적용할 클래스명을 반환한다.
     * @returns {string}
     */
    selectAllLabelClass() {
      if (this.isAllSelected || this.isPartiallySelected) {
        return 'is-checked'
      }

      return 'is-unchecked'
    },

    /**
     * 행 높이 상수를 템플릿에서 참조하기 위한 computed 필드.
     * @returns {number}
     */
    ITEM_ROW_HEIGHT() {
      return ITEM_ROW_HEIGHT
    },

    /**
     * 화살표 아이콘에 적용할 style 객체를 반환한다.
     * @returns {{ backgroundImage: string }}
     */
    arrowIconStyle() {
      return {
        backgroundImage: 'url(' + this.arrowDownImg + ')'
      }
    },

    /**
     * Select All 체크박스에 적용할 style 객체를 반환한다.
     * @returns {{ backgroundImage: string }}
     */
    selectAllCheckboxStyle() {
      const image = this.selectAllImage()
      return {
        backgroundImage: 'url(' + image + ')'
      }
    }
  },
  methods: {
    /**
     * 드롭다운 열림 상태를 토글한다.
     * @returns {void}
     */
    toggleDropdown() {
      this.isOpen = !this.isOpen
    },

    /**
     * 드롭다운을 닫는다.
     * @returns {void}
     */
    closeDropdown() {
      this.isOpen = false
    },

    /**
     * 주어진 항목이 선택되었는지 여부를 반환한다.
     * @param {object} item : 항목 객체
     * @returns {boolean}
     */
    isChecked(item) {
      return this.normalizedSelectedIds.indexOf(item.id) !== -1
    },

    /**
     * 행 클릭 시 동작을 수행한다.
     *  - 멀티: 선택 목록 토글
     *  - 싱글: 선택 / 해제 후 드롭다운 닫기
     * @param {object} item : 항목 객체
     * @returns {void}
     */
    onRowClick(item) {
      if (this.multiple) {
        const currentIds = Array.isArray(this.value) ? this.value.slice() : []
        const nextIds = this.buildNextMultiSelection(currentIds, item.id)

        this.$emit('input', nextIds)
        this.$emit('change', nextIds)
        return
      }

      const currentId = this.normalizedSelectedIds[0] || null
      const nextValue = this.buildNextSingleSelection(currentId, item.id)

      this.$emit('input', nextValue)
      this.$emit('change', nextValue)
      this.closeDropdown()
    },

    /**
     * 멀티 셀렉트에서 하나의 id를 토글한 뒤의 배열을 생성한다.
     * @param {Array<any>} currentIds : 현재 선택된 id 배열
     * @param {any} toggledId : 토글 대상 id
     * @returns {Array<any>}
     */
    buildNextMultiSelection(currentIds, toggledId) {
      const next = currentIds.slice()
      const index = next.indexOf(toggledId)

      if (index === -1) {
        next.push(toggledId)
      } else {
        next.splice(index, 1)
      }

      return next
    },

    /**
     * 싱글 셀렉트에서 현재 값과 토글 대상 id를 받아 다음 값을 계산한다.
     * @param {any} currentId : 현재 선택된 id (또는 null)
     * @param {any} toggledId : 토글 대상 id
     * @returns {any}
     */
    buildNextSingleSelection(currentId, toggledId) {
      if (currentId === toggledId) {
        return null
      }

      return toggledId
    },

    /**
     * Select All 클릭 시 전체 선택/해제를 수행한다.
     * @returns {void}
     */
    onSelectAllClick() {
      if (!this.multiple) {
        return
      }

      if (this.isAllSelected) {
        this.$emit('input', [])
        this.$emit('change', [])
        return
      }

      const allIds = this.items.map(item => item.id)
      this.$emit('input', allIds)
      this.$emit('change', allIds)
    },

    /**
     * 항목별 체크박스에 적용할 클래스명을 반환한다.
     * @param {object} item : 항목 객체
     * @returns {string}
     */
    checkboxClassForItem(item) {
      return this.isChecked(item) ? 'is-checked' : 'is-unchecked'
    },

    /**
     * 항목 라벨에 적용할 클래스명을 반환한다.
     * @param {object} item : 항목 객체
     * @returns {string}
     */
    labelClassForItem(item) {
      return this.isChecked(item) ? 'is-checked' : 'is-unchecked'
    },

    /**
     * 항목별 체크박스에 적용할 backgroundImage를 계산한다.
     * @param {object} item : 항목 객체
     * @returns {{ backgroundImage: string }}
     */
    checkboxStyleForItem(item) {
      const image = this.checkboxImage(item)
      return {
        backgroundImage: 'url(' + image + ')'
      }
    },

    /**
     * 항목별 체크박스에 사용할 이미지 경로를 반환한다.
     * @param {object} item : 항목 객체
     * @returns {string}
     */
    checkboxImage(item) {
      if (this.isChecked(item)) {
        return this.checkboxCheckedImg
      }
      return this.checkboxUncheckedImg
    },

    /**
     * Select All 체크박스에 사용할 이미지 경로를 반환한다.
     * @returns {string}
     */
    selectAllImage() {
      if (this.isAllSelected) {
        return this.checkboxCheckedImg
      }

      if (this.isPartiallySelected) {
        return this.checkboxIndeterminateImg
      }

      return this.checkboxUncheckedImg
    },

    /**
     * 컴포넌트 영역 밖을 클릭했을 때 드롭다운을 닫는다.
     * @param {MouseEvent} event : 클릭 이벤트
     * @returns {void}
     */
    handleClickOutside(event) {
      if (!this.$el.contains(event.target)) {
        this.closeDropdown()
      }
    }
  },
  mounted() {
    document.addEventListener('click', this.handleClickOutside)
  },
  beforeDestroy() {
    document.removeEventListener('click', this.handleClickOutside)
  }
}
</script>

<style scoped>
.virtual-combo-select {
  position: relative;
  width: 320px;
  font-size: 13px;
  margin-bottom: 24px;
}

/* 컨트롤 영역: 직각 사각형 + 옅은 회색 테두리 */
.vcs-control {
  display: flex;
  align-items: center;
  justify-content: space-between;
  min-height: 32px;
  padding: 4px 8px;
  border: 1px solid #bdbdbd;
  border-radius: 0;
  cursor: pointer;
  background-color: #ffffff;
}

.vcs-placeholder {
  color: #aaaaaa;
}

.vcs-summary {
  flex: 1;
  margin-right: 8px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  color: #444444;
}

/* 화살표 아이콘 */
.vcs-arrow-icon {
  width: 10px;
  height: 10px;
  display: inline-block;
  background-position: center;
  background-repeat: no-repeat;
  background-size: contain;
  transition-duration: 0.3s;
  transform: rotate(0deg);
}

.vcs-arrow-icon.open {
  transform: rotate(-180deg);
}

/* 드롭다운: 검은색 테두리 + 직각 */
.vcs-dropdown {
  position: absolute;
  z-index: 2000;
  top: 100%;
  left: 0;
  right: 0;
  margin-top: 4px;
  border: 1px solid #000000;
  border-radius: 0;
  background-color: #ffffff;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

/* 검색 */
.vcs-search-input {
  width: 100%;
  box-sizing: border-box;
  padding: 4px 8px;
  border: 0;
  border-bottom: 1px solid #eeeeee;
  outline: none;
  font-size: 13px;
}

/* 리스트 */
.vcs-options {
  max-height: 260px;
}

/* 각 행: 간격 조금 줄이고 높이 안정화 */
.vcs-option-row {
  display: flex;
  align-items: center;
  padding: 2px 8px;
  min-height: 24px;
  box-sizing: border-box;
  cursor: pointer;
}

/* row hover 시 회색 배경 */
.vcs-option-row:hover {
  background-color: #f0f0f0;
}

.vcs-select-all-row {
  border-bottom: 1px solid #eeeeee;
}

/* 체크박스 공통 */
.vcs-checkbox {
  display: inline-block;
  width: 16px;
  height: 16px;
  cursor: pointer;
  background-position: center;
  background-repeat: no-repeat;
  background-size: contain;
}

/* 라벨 */
.vcs-option-label {
  margin-left: 8px;
  font-size: 12px;
  white-space: nowrap;
  cursor: pointer;
  user-select: none;
  font-family: 'NoteSans', Arial, sans-serif !important;
  line-height: 16px;
}

/* 체크된 상태 */
.vcs-option-label.is-checked {
  color: #444444;
  font-weight: 600;
}

/* 체크 해제 상태 */
.vcs-option-label.is-unchecked {
  color: #333333;
  font-weight: 400;
}
</style>