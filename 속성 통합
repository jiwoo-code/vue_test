// imports
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;

@Override
public List<CompositeVo> buildCompositeVoList(List<Vo1> vo1List, List<Vo2> vo2List, List<Vo3> vo3List) {

    // eqpId 기준으로 lookup map 구성
    Map<String, Vo1> vo1Map = vo1List.stream().collect(Collectors.toMap(Vo1::getEqpId, v -> v, (a,b)->a));
    Map<String, Vo2> vo2Map = vo2List.stream().collect(Collectors.toMap(Vo2::getEqpId, v -> v, (a,b)->a));
    Map<String, Vo3> vo3Map = vo3List.stream().collect(Collectors.toMap(Vo3::getEqpId, v -> v, (a,b)->a));

    // eqpId 전체 집합
    Set<String> allEqpIds = new HashSet<>();
    allEqpIds.addAll(vo1Map.keySet());
    allEqpIds.addAll(vo2Map.keySet());
    allEqpIds.addAll(vo3Map.keySet());

    List<CompositeVo> result = new ArrayList<>();

    for (String eqpId : allEqpIds) {
        Vo1 vo1 = vo1Map.get(eqpId);
        Vo2 vo2 = vo2Map.get(eqpId);
        Vo3 vo3 = vo3Map.get(eqpId);

        CompositeVo.CompositeVoBuilder b = CompositeVo.builder();
        mergeToBuilder(b, vo1, vo2, vo3); // 기존 함수 그대로 재사용
        result.add(b.build());
    }

    return result;
}








// imports
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.math.BigDecimal;

// 예) ServiceImpl 내부
@Override
public CompositeVo buildCompositeVo(Vo1 vo1, Vo2 vo2, Vo3 vo3) {
    CompositeVo.CompositeVoBuilder b = CompositeVo.builder();
    mergeToBuilder(b, vo1, vo2, vo3);   // <- 함수로만 분리
    return b.build();
}

/**
 * 여러 VO를 돌며 동일 이름 필드를 Builder에 주입.
 * vo2의 BigDecimal 값은 vo2.toPercentTruncated(BigDecimal)로 변환해 double/Double로 넣음.
 */
private void mergeToBuilder(CompositeVo.CompositeVoBuilder b, Object vo1, Object vo2, Object vo3) {
    try {
        for (Object src : new Object[]{ vo1, vo2, vo3 }) {
            if (src == null) continue;

            for (PropertyDescriptor pd : Introspector.getBeanInfo(src.getClass(), Object.class).getPropertyDescriptors()) {
                Method getter = pd.getReadMethod();
                if (getter == null) continue;

                Object v = getter.invoke(src);
                if (v == null) continue;

                String name = pd.getName();

                // --- vo2의 BigDecimal만 사용자 정의 변환 적용 ---
                if (src == vo2 && v instanceof BigDecimal) {
                    // (리플렉션 없이 직접 호출) vo2 타입이 확실하면 캐스팅이 가장 빠르고 짧습니다.
                    double dv = ((Vo2) vo2).toPercentTruncated((BigDecimal) v);
                    if (!tryInvoke(b, name, double.class, dv)) {
                        tryInvoke(b, name, Double.class, dv);
                    }
                    continue;
                }
                // -------------------------------------------------

                // 일반 케이스: 선언 타입 → 런타임 타입 순으로 시도 (짧게)
                Class<?> decl = pd.getPropertyType();
                if (!tryInvoke(b, name, decl, v)) {
                    tryInvoke(b, name, v.getClass(), v);
                }
            }
        }
    } catch (Exception e) {
        throw new IllegalStateException("mergeToBuilder failed", e);
    }
}

/** 동일 이름의 빌더 메서드 호출 시도. 성공하면 true */
private boolean tryInvoke(Object builder, String method, Class<?> paramType, Object arg) {
    try {
        builder.getClass().getMethod(method, paramType).invoke(builder, arg);
        return true;
    } catch (ReflectiveOperationException ignore) {
        return false;
    }
}