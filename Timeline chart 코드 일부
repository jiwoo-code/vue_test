import dayjs from "dayjs";

export default {
  data() {
    return {
      slotSeqPalette: [
        "#4E79A7", "#F28E2B", "#E15759", "#76B7B2", "#59A14F",
        "#EDC948", "#B07AA1", "#FF9DA7", "#9C755F", "#BAB0AC"
      ],
      swapGrayColor: "#9E9E9E",
      slotColorBySeq: new Map()
    };
  },

  methods: {
    // =====================
    // 1) setData(data)
    // =====================
    setData(data = []) {
      const rows = Array.isArray(data) ? data : [];

      // 1) pinned row 데이터 생성 후 맨 앞에 추가
      const pinnedRows = this.buildPinnedRowsFromDieExposure(rows);

      // 2) 원본을 건드리지 않게 복제 + pinned prepend
      const mergedRows = [
        ...pinnedRows,
        ...rows.map((row) => ({ ...row }))
      ];

      // 3) slot_seq별 색상 + tooltipText 사전 세팅
      const enrichedRows = mergedRows.map((row) => {
        const slotSeq = row.slot_seq ?? "";
        const itemColor = this.getColorBySlotSeq(slotSeq);

        const infoName = row.info_name ?? "";
        const tooltipText =
          infoName === "swap/exp"
            ? this.buildPinnedTooltipText(row)
            : this.buildNormalTooltipText(row);

        return {
          ...row,
          itemColor,
          tooltipText
        };
      });

      // 4) rows → payload 변환
      const payload = this.buildTimelinePayloadFromRows(enrichedRows);

      // 5) 기존 차트 상태 바인딩
      this.applyPayloadToChartState(payload);
    },

    // =====================
    // 2) pinned row 생성
    // - Die exposure 복사( info_name => swap/exp )
    // - 빈 구간 swap(회색) 생성( info_name => swap/exp )
    // - swap row는 tooltipText 만들 때 필요한 필드를 여기서 "이미" 넣어둠
    // =====================
    buildPinnedRowsFromDieExposure(rows) {
      const dieInfoName = "Die exposure";
      const pinnedInfoName = "swap/exp";

      const segments = rows
        .filter((row) => row.info_name === dieInfoName)
        .map((row) => {
          const startText = row.process_start_tmstp;
          const endText = row.process_end_tmstp;

          const startMs = this.parseTimestampToMs(startText);
          const endMs = this.parseTimestampToMs(endText);

          if (endMs <= startMs) {
            return null;
          }

          return {
            row,
            startMs,
            endMs,
            startText,
            endText
          };
        })
        .filter(Boolean)
        .sort((a, b) => a.startMs - b.startMs);

      const pinnedRows = [];

      // 1) Die exposure 복사 → pinned row로 (info_name: swap/exp)
      segments.forEach((seg) => {
        pinnedRows.push({
          ...seg.row,
          info_name: pinnedInfoName
        });
      });

      // 2) gap → swap 데이터 생성 (info_name: swap/exp)
      //    요구된 tooltip에 필요한 값들을 row에 미리 세팅
      for (let i = 0; i < segments.length - 1; i += 1) {
        const currentSeg = segments[i];
        const nextSeg = segments[i + 1];

        const gapStartMs = currentSeg.endMs;
        const gapEndMs = nextSeg.startMs;

        if (gapEndMs <= gapStartMs) {
          continue;
        }

        pinnedRows.push({
          lot_id: "swap",
          slot_seq: "", // slot_seq 없으면 회색 처리
          module_name: "",
          info_name: pinnedInfoName,

          process_start_tmstp: currentSeg.endText,
          process_end_tmstp: nextSeg.startText,

          layer_id: "-",
          device_id: "-",

          // pinned tooltip 포맷에서 sec 자리에 들어갈 값
          wafer_exp_sec: "-",

          // 나머지는 있어도 되고 없어도 되지만 통일감 위해 빈 값
          status: "",
          chuck_id: "",
          step_id: "",
          reticle_id: "",
          swap_time: "",
          interval: "",
          duration: "",
          loss: ""
        });
      }

      return pinnedRows;
    },

    // =====================
    // 3) rows → payload(categories/intervals/domain)
    // - y축 라벨은 info_name
    // - pinned row는 categories[0]가 되도록 "swap/exp" 강제
    // =====================
    buildTimelinePayloadFromRows(rows) {
      const pinnedInfoName = "swap/exp";

      const categories = [pinnedInfoName];
      const seen = new Set([pinnedInfoName]);

      rows.forEach((row) => {
        const infoName = row.info_name ?? "UNKNOWN";
        if (!seen.has(infoName)) {
          seen.add(infoName);
          categories.push(infoName);
        }
      });

      const categoryIndexByInfoName = new Map();
      categories.forEach((name, index) => categoryIndexByInfoName.set(name, index));

      const intervals = [];

      rows.forEach((row, rowIndex) => {
        const infoName = row.info_name ?? "UNKNOWN";
        const categoryIndex = categoryIndexByInfoName.get(infoName);

        const startMs = this.parseTimestampToMs(row.process_start_tmstp);
        const endMs = this.parseTimestampToMs(row.process_end_tmstp);

        if (typeof startMs !== "number" || typeof endMs !== "number") {
          return;
        }
        if (endMs <= startMs) {
          return;
        }

        intervals.push({
          id: `${infoName}-${rowIndex}`,
          raw: row, // tooltipText/itemColor를 여기서 사용
          itemStyle: { color: row.itemColor },
          value: [categoryIndex, startMs, endMs, infoName]
        });
      });

      let domainStart = null;
      let domainEnd = null;

      intervals.forEach((item) => {
        const startMs = item.value[1];
        const endMs = item.value[2];

        if (domainStart === null || startMs < domainStart) {
          domainStart = startMs;
        }
        if (domainEnd === null || endMs > domainEnd) {
          domainEnd = endMs;
        }
      });

      return {
        categories,
        intervals,
        domainStart: domainStart ?? 0,
        domainEnd: domainEnd ?? 0
      };
    },

    // =====================
    // 4) 기존 setData의 상태 반영 로직(분리)
    // =====================
    applyPayloadToChartState(payload = {}) {
      const categories = Array.isArray(payload.categories) ? payload.categories : [];
      const intervals = Array.isArray(payload.intervals) ? payload.intervals : [];
      const resolvedDomain = this.resolveDomain(payload, intervals);
      const span = resolvedDomain.end - resolvedDomain.start;

      this.categories = categories;
      this.pinnedCategory = categories.length ? categories[0] : null;
      this.scrollCategories = categories.slice(1);

      this.pinnedIntervals = intervals
        .filter((item) => item && item.value && item.value[0] === 0)
        .map((item) => ({
          ...item,
          value: [0, item.value[1], item.value[2], item.value[3]]
        }));

      this.scrollIntervals = intervals
        .filter((item) => item && item.value && item.value[0] > 0)
        .map((item) => ({
          ...item,
          value: [item.value[0] - 1, item.value[1], item.value[2], item.value[3]]
        }));

      this.selectedCategoryIndex =
        typeof payload.selectedCategoryIndex === "number"
          ? payload.selectedCategoryIndex
          : null;

      this.domainStart = resolvedDomain.start;
      this.domainEnd = resolvedDomain.end;

      const defaultViewStart =
        span > 0 ? resolvedDomain.start + span * 0.22 : resolvedDomain.start;
      const defaultViewEnd =
        span > 0 ? resolvedDomain.start + span * 0.42 : resolvedDomain.end;

      const defaultCursorStart =
        span > 0 ? resolvedDomain.start + span * 0.28 : resolvedDomain.start;
      const defaultCursorEnd =
        span > 0 ? resolvedDomain.start + span * 0.35 : resolvedDomain.end;

      this.viewStart = this.normalizeTime(payload.viewStart, defaultViewStart);
      this.viewEnd = this.normalizeTime(payload.viewEnd, defaultViewEnd);
      this.cursorStart = this.normalizeTime(payload.cursorStart, defaultCursorStart);
      this.cursorEnd = this.normalizeTime(payload.cursorEnd, defaultCursorEnd);
    },

    // =====================
    // 5) dayjs 시간 파싱 (과한 대비 제거)
    // =====================
    parseTimestampToMs(text) {
      const trimmed = text.trim();
      const dotIndex = trimmed.indexOf(".");

      let normalized = trimmed;
      if (dotIndex >= 0) {
        const prefix = trimmed.slice(0, dotIndex);
        const fraction = trimmed.slice(dotIndex + 1).replace(/[^0-9]/g, "");
        const msText = (fraction + "000").slice(0, 3);
        normalized = `${prefix}.${msText}`;
      }

      return dayjs(normalized, "YYYY-MM-DD HH:mm:ss.SSS", true).valueOf();
    },

    // =====================
    // 6) 색상: slot_seq 없으면 회색
    // =====================
    getColorBySlotSeq(slotSeq) {
      if (!slotSeq) {
        return this.swapGrayColor;
      }

      const cached = this.slotColorBySeq.get(slotSeq);
      if (cached) {
        return cached;
      }

      let hashValue = 0;
      for (let i = 0; i < slotSeq.length; i += 1) {
        hashValue = (hashValue * 31 + slotSeq.charCodeAt(i)) >>> 0;
      }

      const index = hashValue % this.slotSeqPalette.length;
      const color = this.slotSeqPalette[index];

      this.slotColorBySeq.set(slotSeq, color);
      return color;
    },

    // =====================
    // 7) tooltipText 생성 (C안)
    // - tooltip에서는 그냥 row.tooltipText만 보여줌
    // =====================
    buildPinnedTooltipText(row) {
      return [
        `Wafer: ${row.lot_id}#${row.slot_seq}`,
        `Layer: ${row.layer_id}`,
        `Device: ${row.device_id}`,
        `Time: ${row.process_start_tmstp} ~ ${row.process_end_tmstp} (${row.wafer_exp_sec} sec)`
      ].join("\n");
    },

    buildNormalTooltipText(row) {
      return [
        `Wafer: ${row.lot_id}#${row.slot_seq} (${row.status})`,
        `Chuck: ${row.chuck_id}`,
        `STEP/RETICLE: ${row.step_id}/${row.reticle_id}`,
        `Layer: ${row.layer_id}`,
        `Swap TIme: ${row.swap_time} sec`,
        `Expose Time: ${row.wafer_exp_sec} sec`,
        `Sequence: ${row.module_name}/${row.info_name}`,
        `Start: ${row.process_start_tmstp}`,
        `End: ${row.process_end_tmstp}`,
        `Idle Time: ${row.interval} sec`,
        `Process Itme: ${row.duration} sec`,
        `Loss: ${row.loss}`
      ].join("\n");
    },

    // =====================
    // 8) Tooltip 렌더 (분기 없음)
    // - 색상: row.itemColor
    // - 내용: row.tooltipText
    // =====================
    buildTooltipHtml(params) {
      const intervalItem = params?.data ?? {};
      const row = intervalItem.raw ?? {};

      const itemColor = row.itemColor ?? this.swapGrayColor;
      const tooltipText = row.tooltipText ?? "";

      const escaped = this.escapeHtml(tooltipText).replace(/\n/g, "<br/>");

      return `
        <div style="
          padding: 10px 12px;
          border-radius: 8px;
          background: ${itemColor};
          color: #ffffff;
          max-width: 520px;
          line-height: 1.35;
          box-shadow: 0 6px 18px rgba(0,0,0,0.18);
        ">
          ${escaped}
        </div>
      `;
    },

    escapeHtml(text) {
      return String(text)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }
  }
};




SyTimelineChart.vue에서 option 만드는 부분의 tooltip을 아래로 교체하세요.


tooltip: {
  trigger: "item",
  enterable: true,
  backgroundColor: "transparent",
  borderWidth: 0,
  padding: 0,
  extraCssText: "box-shadow:none;",
  formatter: (params) => this.buildTooltipHtml(params)
}