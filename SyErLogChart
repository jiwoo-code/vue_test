<template>
  <div class="sy-erlog-wrap">
    <div class="legend-row">
      <button
        type="button"
        class="legend-item"
        :class="{ off: !legendFilter.hasSy }"
        @click="toggleLegend('hasSy')"
      >
        <span class="swatch has-sy"></span>
        <span>Has SY Data</span>
      </button>

      <button
        type="button"
        class="legend-item"
        :class="{ off: !legendFilter.incompleteSy }"
        @click="toggleLegend('incompleteSy')"
      >
        <span class="swatch incomplete"></span>
        <span>Has Incomplete SY Data</span>
      </button>

      <button
        type="button"
        class="legend-item"
        :class="{ off: !legendFilter.reject }"
        @click="toggleLegend('reject')"
      >
        <span class="swatch reject"></span>
        <span>Has Reject Wafer</span>
      </button>
    </div>

    <v-chart
      ref="chart"
      class="sy-erlog-chart"
      :option="chartOption"
      :autoresize="true"
      :update-options="updateOptions"
      @click="onChartClick"
    />
  </div>
</template>

<script>
import { use, graphic } from 'echarts/core';
import { CanvasRenderer } from 'echarts/renderers';
import { CustomChart } from 'echarts/charts';
import { GridComponent, TooltipComponent, DataZoomComponent } from 'echarts/components';
import VChart from 'vue-echarts';

use([CanvasRenderer, CustomChart, GridComponent, TooltipComponent, DataZoomComponent]);

const COLOR_RULES = Object.freeze({
  hasSy: '#3b82f6',
  incompleteSy: '#f59e0b',
  reject: '#ef4444'
});

const TOOLTIP_TEXT_COLOR = Object.freeze({
  [COLOR_RULES.hasSy]: '#ffffff',
  [COLOR_RULES.incompleteSy]: '#111827',
  [COLOR_RULES.reject]: '#ffffff'
});

export default {
  name: 'SyErLogChart',
  components: {
    'v-chart': VChart
  },
  data() {
    return {
      updateOptions: {
        notMerge: false
      },

      isTooltipEnabled: true,

      items: [],

      // =====================
      // 축 고정(전체 데이터 기준)
      // =====================
      baseCategories: [],
      baseDomainStart: 0,
      baseDomainEnd: 0,
      categoryIndexMap: new Map(),

      // =====================
      // 실제 표시 데이터
      // =====================
      seriesData: [],

      legendFilter: {
        hasSy: true,
        incompleteSy: true,
        reject: true
      }
    };
  },
  computed: {
    chartOption() {
      const base = this.buildBaseOption();

      const series = base.series.map((item) => {
        if (item && item.id === 'erlog-series') {
          return {
            ...item,
            data: this.seriesData
          };
        }
        return item;
      });

      return {
        ...base,
        xAxis: {
          ...base.xAxis,
          min: this.baseDomainStart,
          max: this.baseDomainEnd
        },
        yAxis: {
          ...base.yAxis,
          data: this.baseCategories
        },
        tooltip: {
          ...base.tooltip,
          show: this.isTooltipEnabled
        },
        series
      };
    }
  },
  methods: {
    // =====================
    // Public API
    // =====================
    setData(data) {
      this.items = Array.isArray(data) ? data : [];

      this.prepareBaseAxis(this.items);
      this.seriesData = this.buildSeriesData(this.items);

      this.$nextTick(() => {
        this.resetZoom();
      });
    },

    // =====================
    // 범례 토글
    // =====================
    toggleLegend(key) {
      const current = this.legendFilter[key];
      if (typeof current !== 'boolean') return;

      this.legendFilter = {
        ...this.legendFilter,
        [key]: !current
      };

      this.seriesData = this.buildSeriesData(this.items);
    },

    // =====================
    // Chart instance
    // =====================
    getChartInstance() {
      const chartComponent = this.$refs.chart;
      if (!chartComponent) return null;

      if (typeof chartComponent.getEchartsInstance === 'function') {
        return chartComponent.getEchartsInstance();
      }

      return chartComponent.chart || null;
    },

    resetZoom() {
      const chart = this.getChartInstance();
      if (!chart) return;

      chart.dispatchAction({
        type: 'dataZoom',
        dataZoomId: 'erlog-slider',
        start: 0,
        end: 100
      });

      chart.dispatchAction({
        type: 'dataZoom',
        dataZoomId: 'erlog-inside',
        start: 0,
        end: 100
      });
    },

    // =====================
    // Axis preparation
    // =====================
    prepareBaseAxis(items) {
      const categories = [];
      const categoryIndexMap = new Map();

      let minTime = null;
      let maxTime = null;

      items.forEach((item) => {
        if (!item) return;

        const eqpId = item.eqpId ?? '';
        if (!categoryIndexMap.has(eqpId)) {
          categoryIndexMap.set(eqpId, categories.length);
          categories.push(eqpId);
        }

        const start = this.toTimeValue(item.lotStart);
        const end = this.toTimeValue(item.lotFinish);
        if (start == null || end == null) return;

        minTime = minTime == null ? start : Math.min(minTime, start);
        maxTime = maxTime == null ? end : Math.max(maxTime, end);
      });

      if (minTime == null || maxTime == null) {
        const now = Date.now();
        minTime = now - 60 * 60 * 1000;
        maxTime = now + 60 * 60 * 1000;
      }

      const padding = 20 * 60 * 1000;

      this.baseCategories = categories;
      this.categoryIndexMap = categoryIndexMap;
      this.baseDomainStart = minTime - padding;
      this.baseDomainEnd = maxTime + padding;
    },

    // =====================
    // Series building
    // =====================
    buildSeriesData(items) {
      const result = [];

      items.forEach((item) => {
        if (!item) return;

        const type = this.resolveType(item);
        if (!this.legendFilter[type]) return;

        const eqpId = item.eqpId ?? '';
        const categoryIndex = this.categoryIndexMap.get(eqpId);
        if (categoryIndex == null) return;

        const start = this.toTimeValue(item.lotStart);
        const end = this.toTimeValue(item.lotFinish);
        if (start == null || end == null) return;

        const color = COLOR_RULES[type];

        result.push({
          name: item.lotId,
          value: [categoryIndex, start, end, Math.max(0, end - start)],
          itemStyle: { color },
          tooltipHtml: this.buildTooltipHtml(item, color),
          payload: { ...item }
        });
      });

      return result;
    },

    resolveType(item) {
      if (item.rejectWafer >= 1) return 'reject';
      if (item.avgSyCount >= 63) return 'hasSy';
      return 'incompleteSy';
    },

    // =====================
    // Chart option base
    // =====================
    buildBaseOption() {
      return {
        backgroundColor: '#ffffff',
        animation: false,
        grid: {
          left: 80,
          right: 32,
          top: 20,
          bottom: 120
        },
        tooltip: {
          trigger: 'item',
          triggerOn: 'mousemove',
          confine: false,
          appendToBody: true,
          className: 'erlog-tooltip',
          backgroundColor: 'transparent',
          borderWidth: 0,
          padding: 0,
          showDelay: 0,
          hideDelay: 0,
          transitionDuration: 0,
          extraCssText: 'box-shadow: none; pointer-events: none;',
          formatter: this.getTooltipHtml
        },
        dataZoom: [
          {
            id: 'erlog-slider',
            type: 'slider',
            xAxisIndex: 0,
            filterMode: 'weakFilter',
            showDataShadow: false,
            brushSelect: false,
            bottom: 10,
            height: 22,
            labelFormatter: ''
          },
          {
            id: 'erlog-inside',
            type: 'inside',
            xAxisIndex: 0,
            filterMode: 'weakFilter',
            zoomOnMouseWheel: true,
            moveOnMouseWheel: false,
            moveOnMouseMove: false
          }
        ],
        xAxis: {
          type: 'time',
          min: 0,
          max: 0,
          minInterval: 30 * 60 * 1000,
          splitNumber: 48,
          axisLine: {
            lineStyle: { color: '#cbd5e1' }
          },
          axisLabel: {
            color: '#475569',
            interval: 0,
            hideOverlap: true,
            rotate: 90,
            margin: 6,
            formatter: (value) => this.formatAxisLabel(value)
          },
          splitLine: {
            show: true,
            lineStyle: { color: '#e2e8f0' }
          }
        },
        yAxis: {
          type: 'category',
          inverse: true,
          data: [],
          axisTick: { show: false },
          axisLine: { show: false },
          axisLabel: { color: '#334155' }
        },
        series: [
          {
            id: 'erlog-series',
            type: 'custom',
            renderItem: this.renderItem,
            itemStyle: { opacity: 0.92 },
            encode: { x: [1, 2], y: 0 },
            data: []
          }
        ]
      };
    },

    // =====================
    // Render item
    // =====================
    renderItem(params, api) {
      const categoryIndex = api.value(0);
      const start = api.coord([api.value(1), categoryIndex]);
      const end = api.coord([api.value(2), categoryIndex]);
      const height = 35;

      const rectShape = graphic.clipRectByRect(
        {
          x: start[0],
          y: start[1] - height / 2,
          width: end[0] - start[0],
          height
        },
        {
          x: params.coordSys.x,
          y: params.coordSys.y,
          width: params.coordSys.width,
          height: params.coordSys.height
        }
      );

      return (
        rectShape && {
          type: 'rect',
          transition: ['shape'],
          shape: rectShape,
          style: api.style()
        }
      );
    },

    // =====================
    // Interaction
    // =====================
    onChartClick(params) {
      if (!params || params.seriesId !== 'erlog-series' || !params.data) return;

      const payload = params.data.payload;
      if (!payload) return;

      const clickedTime = this.getClickedTime(params);

      this.$emit('select-lot', {
        lot: payload,
        clickedTime
      });
    },

    getClickedTime(params) {
      const data = params && params.data;
      const start = data && data.value ? data.value[1] : null;
      const end = data && data.value ? data.value[2] : null;

      const chart = this.getChartInstance();
      if (!chart || !params || !params.event) return start;

      const offsetX = params.event.offsetX;
      const offsetY = params.event.offsetY;
      if (offsetX == null || offsetY == null) return start;

      const value = chart.convertFromPixel({ xAxisIndex: 0 }, [offsetX, offsetY]);
      const candidate = Array.isArray(value) ? value[0] : value;

      if (typeof candidate === 'number' && !Number.isNaN(candidate)) {
        if (start != null && end != null) {
          return Math.min(Math.max(candidate, start), end);
        }
        return candidate;
      }

      return start;
    },

    // =====================
    // Tooltip content
    // =====================
    getTooltipHtml(params) {
      const data = params && params.data ? params.data : null;
      return data && data.tooltipHtml ? data.tooltipHtml : '';
    },
    buildTooltipHtml(item, color) {
      if (!item) return '';

      const textColor = TOOLTIP_TEXT_COLOR[color] || '#ffffff';
      const lines = [
        `Lot ID: ${this.safeText(item.lotId)}`,
        `Layer: ${this.safeText(item.layer)}`,
        `Device: ${this.safeText(item.device)}`,
        `Lot Start: ${this.safeText(item.lotStart)}`,
        `Lot Finish: ${this.safeText(item.lotFinish)}`,
        `Lot Size: ${this.safeText(item.lotSize)}`,
        `Reject Wafer: ${this.safeText(item.rejectWafer)}`
      ].join('<br/>');

      return [
        '<div style="',
        `background:${color};`,
        `color:${textColor};`,
        'padding:8px 10px;',
        'border-radius:8px;',
        'font-size:12px;',
        'line-height:1.5;',
        'box-shadow:0 10px 20px rgba(15,23,42,0.2);',
        '">',
        lines,
        '</div>'
      ].join('');
    },
    safeText(value) {
      return value == null ? '-' : String(value);
    },

    // =====================
    // Formatting / time
    // =====================
    formatAxisLabel(value) {
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return '';

      return [
        `${this.pad2(date.getMonth() + 1)}-${this.pad2(date.getDate())}`,
        `${this.pad2(date.getHours())}:${this.pad2(date.getMinutes())}`
      ].join(' ');
    },
    pad2(value) {
      return String(value).padStart(2, '0');
    },
    toTimeValue(value) {
      if (value == null) return null;
      if (typeof value === 'number') return value;

      const parsed = this.parseDateTimeMs(value);
      if (parsed != null) return parsed;

      const time = new Date(value).getTime();
      return Number.isNaN(time) ? null : time;
    },
    parseDateTimeMs(value) {
      const match = /^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})\.(\d{3})$/.exec(
        String(value ?? '').trim()
      );
      if (!match) return null;

      const [, year, month, day, hour, minute, second, ms] = match;

      const date = new Date(
        Number(year),
        Number(month) - 1,
        Number(day),
        Number(hour),
        Number(minute),
        Number(second),
        Number(ms)
      );

      return Number.isNaN(date.getTime()) ? null : date.getTime();
    }
  }
};
</script>

<style scoped>
.sy-erlog-wrap {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.legend-row {
  display: flex;
  justify-content: flex-end;
  gap: 10px 16px;
  flex-wrap: wrap;
}

.legend-item {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  border: 0;
  background: transparent;
  padding: 0;
  cursor: pointer;
  color: #334155;
  font-size: 12px;
  line-height: 1.2;
}

.legend-item.off {
  opacity: 0.35;
}

.swatch {
  width: 10px;
  height: 10px;
  border-radius: 999px;
  display: inline-block;
}

.swatch.has-sy {
  background: #3b82f6;
}

.swatch.incomplete {
  background: #f59e0b;
}

.swatch.reject {
  background: #ef4444;
}

.sy-erlog-chart {
  width: 100%;
  height: 220px;
  border-radius: 14px;
  overflow: hidden;
  background: #ffffff;
  border: 1px solid rgba(15, 23, 42, 0.12);
}
</style>