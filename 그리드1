
Vue2 (ag-Grid) – MxTrendGrid.vue
코드 복사
Vue
<template>
  <div class="mx-trend-wrap">
    <div class="toolbar">
      <label>Departments</label>
      <input v-model="departmentsCsv" placeholder="예: ASSY,PACK" />
      <label>Start</label>
      <input v-model="startDate" type="date" />
      <label>End</label>
      <input v-model="endDate" type="date" />
      <button @click="fetchTrend">조회</button>
    </div>

    <ag-grid-vue
      class="ag-theme-alpine"
      style="width: 100%; height: 560px"
      :columnDefs="columnDefs"
      :defaultColDef="defaultColDef"
      :rowData="rowData"
      :animateRows="true"
      :suppressDragLeaveHidesColumns="true"
      :rowClassRules="rowClassRules"
    />
  </div>
</template>

<script>
import axios from 'axios';
import { AgGridVue } from 'ag-grid-vue';

export default {
  name: 'MxTrendGrid',
  components: { AgGridVue },
  data() {
    return {
      departments: ['depart'],
      startDate: '2025-01-01',
      endDate: '2025-01-31',
      rowData: [],
      columnDefs: [],
      defaultColDef: {
        resizable: true,
        sortable: true,
        filter: 'agTextColumnFilter',
        valueFormatter: (p) => {
          const v = p.value;
          if (v === null || v === undefined || Number.isNaN(v)) return '';
          if (typeof v === 'number') return v.toFixed(4);
          return v;
        }
      },
      rowClassRules: {
        'row-sum':        p => p.data?.action_name === 'sum',
        'row-daily':      p => p.data?.action_name === 'Daily_MAction 수',
        'row-mx-day-min': p => p.data?.action_name === 'MX/day(min)'
      }
    };
  },
  computed: {
    departmentsCsv: {
      get() { return this.departments.join(','); },
      set(v) { this.departments = v.split(',').map(s => s.trim()).filter(Boolean); }
    }
  },
  mounted() { this.fetchTrend(); },
  methods: {
    async fetchTrend() {
      const params = new URLSearchParams();
      this.departments.forEach(d => params.append('departments', d));
      params.append('start', this.startDate);
      params.append('end', this.endDate);

      const { data } = await axios.get('/api/mx/trend', { params });
      this.rowData = Array.isArray(data) ? data : [];

      const fixed = new Set(['action_name', 'component', '항목별 ALL', 'day(sec)', 'day(min)']);
      const eqpKeys = this.collectEqpKeys(this.rowData, fixed);

      this.columnDefs = [
        { headerName: 'MACTION',   field: 'action_name', pinned: 'left', minWidth: 140 },
        { headerName: 'COMPONENT', field: 'component',   pinned: 'left', minWidth: 120 },
        ...eqpKeys.map(k => ({
          headerName: k.toUpperCase(),
          field: k,
          type: 'rightAligned',
          cellClass: p => (typeof p.value === 'number' ? 'ag-right-aligned-cell' : '')
        })),
        { headerName: '항목별 ALL', field: '항목별 ALL', type: 'rightAligned', minWidth: 120 },
        { headerName: 'day(sec)',  field: 'day(sec)',    type: 'rightAligned', minWidth: 110 },
        { headerName: 'day(min)',  field: 'day(min)',    type: 'rightAligned', minWidth: 110 }
      ];
    },
    collectEqpKeys(rows, fixed) {
      const set = new Set();
      rows.forEach(r => Object.keys(r || {}).forEach(k => {
        if (!fixed.has(k) && k.toLowerCase().startsWith('eqp')) set.add(k);
      }));
      return Array.from(set).sort((a, b) => {
        const na = parseInt(a.replace(/^\D+/g, ''), 10);
        const nb = parseInt(b.replace(/^\D+/g, ''), 10);
        if (Number.isNaN(na) || Number.isNaN(nb)) return a.localeCompare(b);
        return na - nb;
      });
    }
  }
};
</script>

<style scoped>
.mx-trend-wrap { width: 100%; }
.toolbar { display: flex; gap: 8px; margin-bottom: 8px; align-items: center; }
.toolbar input { width: 160px; }
.row-sum        { background: rgba(0,0,0,0.03); font-weight: 600; }
.row-daily      { background: rgba(0,128,255,0.06); }
.row-mx-day-min { background: rgba(255,165,0,0.10); }
</style>
Spring Boot
1) DTO – MxHistoryRow.java
코드 복사
Java
package com.example.mx.domain;

import lombok.Getter;
import lombok.Setter;

/** MX 이력 단일 행 (DB numeric → Java double) */
@Getter
@Setter
public class MxHistoryRow {
    private String eqpId;
    private String actionName;
    private String component;
    private double mxSeconds; // numeric
}
2) Mapper 시그니처 – MxMapper.java  (구현/XML 생략)
코드 복사
Java
package com.example.mx.application;

import com.example.mx.domain.MxHistoryRow;
import java.util.List;

/**
 * 부서들 + 기간(문자열)로 MX 이력을 한 번에 로드
 * - 종료일 포함(+1day)은 SQL에서 처리 권장
 * - 정렬: line, eqpId, summaryDate, mxTime (action_name은 정렬 안 함)
 */
public interface MxMapper {
    List<MxHistoryRow> loadAllMxHistoryByDepartments(
            List<String> departments,
            String startDate,  // "yyyy-MM-dd"
            String endDate     // "yyyy-MM-dd"
    );
}
3) Service – MxTrendService.java
코드 복사
Java
package com.example.mx.application;

import java.util.List;
import java.util.Map;

/** 반환 컬럼: action_name, component, eqp..., 항목별 ALL, day(sec), day(min) */
public interface MxTrendService {
    List<Map<String, Object>> buildTrend(List<String> departments, String startDate, String endDate);
}


4) ServiceImpl – MxTrendServiceImpl.java  (DB 정렬 존중, 중복 제거만)
코드 복사
Java




package com.example.mx.application;

import com.example.mx.domain.MxHistoryRow;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class MxTrendServiceImpl implements MxTrendService {

    private final MxMapper mxMapper;

    public MxTrendServiceImpl(MxMapper mxMapper) {
        this.mxMapper = mxMapper;
    }

    @Override
    public List<Map<String, Object>> buildTrend(List<String> departments, String startDate, String endDate) {
        if (departments == null || departments.isEmpty()) return Collections.emptyList();

        final List<MxHistoryRow> mxHistories =
                mxMapper.getAllMxHistoryByDepartments(departments, startDate, endDate);
        if (mxHistories == null || mxHistories.isEmpty()) return Collections.emptyList();

        // EQP 컬럼 목록: DB 등장 순서 유지 + 중복 제거
        final List<String> eqpIds = mxHistories.stream()
                .map(MxHistoryRow::getEqpId)
                .filter(Objects::nonNull)
                .distinct()
                .collect(Collectors.toList());

        // 피벗 구조 만들기 (actionName+component 조합별 설비별 mxSeconds 합계 계산)
        final Map<String, Map<String, Double>> pivot = new LinkedHashMap<>();
        for (MxHistoryRow historyRow : mxHistories) {
            final String actionName = historyRow.getActionName();
            final String component = historyRow.getComponent() == null ? "" : historyRow.getComponent();
            final String pivotKey = actionName + "|" + component;

            Map<String, Double> equipmentSums = pivot.computeIfAbsent(pivotKey, key -> new LinkedHashMap<>());
            equipmentSums.merge(historyRow.getEqpId(), historyRow.getMxSeconds(), Double::sum);
        }

        // 피벗을 리스트 형태로 변환
        final List<Map<String, Object>> table = new ArrayList<>();
        for (Map.Entry<String, Map<String, Double>> pivotEntry : pivot.entrySet()) {
            final String pivotKey = pivotEntry.getKey();
            final int separatorIndex = pivotKey.indexOf('|');
            final String actionName = separatorIndex >= 0 ? pivotKey.substring(0, separatorIndex) : pivotKey;
            final String component = separatorIndex >= 0 ? pivotKey.substring(separatorIndex + 1) : "";

            final Map<String, Double> equipmentSums = pivotEntry.getValue();

            Map<String, Object> rowMap = new LinkedHashMap<>();
            rowMap.put("ActionName", actionName);
            rowMap.put("component", component);
            for (String eqpId : eqpIds) {
                // 원값 유지 (최종 출력 직전에만 반올림)
                rowMap.put(eqpId, equipmentSums.getOrDefault(eqpId, 0.0));
            }
            table.add(rowMap);
        }

        // actionName 기준으로 재정렬
        table.sort(Comparator.comparing(
            row -> ((String) row.get("ActionName")).toLowerCase(),
            Comparator.nullsLast(String::compareTo)
        ));

        // 설비별 합계행(열 방향 합계): actionName = "sum"
        Map<String, Object> equipmentTotalsRow = new LinkedHashMap<>();
        equipmentTotalsRow.put("ActionName", "sum");
        equipmentTotalsRow.put("component", null);
        for (String eqpId : eqpIds) {
            double columnSum = table.stream()
                    .mapToDouble(row -> ((Number) row.getOrDefault(eqpId, 0.0)).doubleValue())
                    .sum();
            equipmentTotalsRow.put(eqpId, columnSum); // 원값
        }
        table.add(equipmentTotalsRow);

        // 각 행의 합계(행 방향 합계) → rowSum
        for (Map<String, Object> row : table) {
            double rowSum = eqpIds.stream()
                    .mapToDouble(eqpId -> ((Number) row.getOrDefault(eqpId, 0.0)).doubleValue())
                    .sum();
            row.put("rowSum", rowSum); // 원값
        }

        // Daily_MAction 수(설비별 count) 행: actionName = "dailyMActionCount"
        Map<String, Long> dailyCountByEqp = mxHistories.stream()
                .filter(historyRow -> "Daily_MAction".equals(historyRow.getActionName()))
                .collect(Collectors.groupingBy(
                        MxHistoryRow::getEqpId, LinkedHashMap::new, Collectors.counting()
                ));

        Map<String, Object> dailyCountRow = new LinkedHashMap<>();
        dailyCountRow.put("ActionName", "dailyMActionCount");
        dailyCountRow.put("component", null);
        long dailyTotalCount = 0L;
        for (String eqpId : eqpIds) {
            long count = dailyCountByEqp.getOrDefault(eqpId, 0L);
            dailyCountRow.put(eqpId, count); // 정수 유지
            dailyTotalCount += count;
        }
        dailyCountRow.put("rowSum", dailyTotalCount); // 정수 합
        dailyCountRow.put("daySec", null);
        dailyCountRow.put("dayMin", null);

        // daySec, dayMin 계산 (분모 0 보호)
        double denominator = (dailyTotalCount == 0L) ? 1.0 : (double) dailyTotalCount;
        for (Map<String, Object> row : table) {
            double rowSum = ((Number) row.getOrDefault("rowSum", 0.0)).doubleValue();
            row.put("daySec", rowSum / denominator);
            row.put("dayMin", (rowSum / denominator) / 60.0);
        }

        // MX/day(min) 행: 설비합 / 설비별 daily count / 60
        Map<String, Object> mxPerDayMinRow = new LinkedHashMap<>();
        mxPerDayMinRow.put("ActionName", "mxPerDayMin");
        mxPerDayMinRow.put("component", null);
        double mxDayMinTotal = 0.0;
        for (String eqpId : eqpIds) {
            double equipmentSum = ((Number) equipmentTotalsRow.getOrDefault(eqpId, 0.0)).doubleValue();
            long dailyCount = ((Number) dailyCountRow.getOrDefault(eqpId, 0L)).longValue();
            double value = (dailyCount == 0L) ? 0.0 : (equipmentSum / dailyCount / 60.0);
            mxPerDayMinRow.put(eqpId, value); // 원값
            mxDayMinTotal += value;
        }
        mxPerDayMinRow.put("rowSum", mxDayMinTotal);
        mxPerDayMinRow.put("daySec", null);
        mxPerDayMinRow.put("dayMin", null);

        // 최종 출력: eqp/rowSum/daySec/dayMin 4자리 반올림 (count는 정수 유지, null은 그대로 유지)
        List<Map<String, Object>> result = new ArrayList<>();
        for (Map<String, Object> row : table) result.add(roundRowForOutput(row, eqpIds));
        result.add(roundRowForOutput(dailyCountRow, eqpIds));
        result.add(roundRowForOutput(mxPerDayMinRow, eqpIds));

        return result;
    }

    // ===== Helpers =====

    private static double round4(double value) {
        return Math.round(value * 10000.0) / 10000.0;
    }

    /** 출력용 반올림: eqp계열/rowSum/daySec/dayMin은 4자리 반올림, count는 정수 유지, null은 그대로 */
    private static Map<String, Object> roundRowForOutput(Map<String, Object> row, List<String> eqpIds) {
        Map<String, Object> outputRow = new LinkedHashMap<>();
        outputRow.put("ActionName", row.get("ActionName"));
        outputRow.put("component", row.get("component"));

        for (String eqpId : eqpIds) {
            Object value = row.get(eqpId);
            if (value == null) {
                outputRow.put(eqpId, null);
            } else if (value instanceof Integer || value instanceof Long) {
                outputRow.put(eqpId, value);
            } else if (value instanceof Number) {
                outputRow.put(eqpId, round4(((Number) value).doubleValue()));
            } else {
                outputRow.put(eqpId, value);
            }
        }

        Object rowSum = row.get("rowSum");
        if (rowSum == null) {
            outputRow.put("rowSum", null);
        } else if (rowSum instanceof Integer || rowSum instanceof Long) {
            outputRow.put("rowSum", rowSum);
        } else if (rowSum instanceof Number) {
            outputRow.put("rowSum", round4(((Number) rowSum).doubleValue()));
        } else {
            outputRow.put("rowSum", rowSum);
        }

        Object daySec = row.get("daySec");
        outputRow.put("daySec", (daySec instanceof Number) ? round4(((Number) daySec).doubleValue()) : daySec);

        Object dayMin = row.get("dayMin");
        outputRow.put("dayMin", (dayMin instanceof Number) ? round4(((Number) dayMin).doubleValue()) : dayMin);

        return outputRow;
    }
}



5) Controller – MxTrendController.java
코드 복사
Java
package com.example.mx.presentation;

import com.example.mx.application.MxTrendService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

/** 날짜는 String("yyyy-MM-dd")으로 주고받습니다. */
@RestController
@RequestMapping("/api/mx")
public class MxTrendController {

    private final MxTrendService mxTrendService;

    public MxTrendController(MxTrendService mxTrendService) {
        this.mxTrendService = mxTrendService;
    }

    @GetMapping("/trend")
    public ResponseEntity<List<Map<String, Object>>> getTrend(
            @RequestParam("departments") List<String> departments,
            @RequestParam("start") String startDate,
            @RequestParam("end") String endDate
    ) {
        return ResponseEntity.ok(mxTrendService.buildTrend(departments, startDate, endDate));
    }
}
Controller 테스트 (심플 포맷)
지우님 포맷 그대로 맞췄습니다.
@StandaloneConfiguration + @EnableGlobalMethodSecurity(prePostEnabled = true)
@Bean으로 컨트롤러/서비스 생성, 매퍼는 @MockBean
buildStandaloneMockMvc(controller), loginAsUser() 호출
perform(getRequest(...)) 사용
테스트 메서드 네이밍: {컨트롤러함수명}_SHOULD_return_status_200_WHENEVER
코드 복사
Java
package com.example.mx.presentation;

import com.example.mx.application.MxMapper;
import com.example.mx.application.MxTrendService;
import com.example.mx.application.MxTrendServiceImpl;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.mock.mockito.MockBean;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * 베이스 테스트 클래스에서 제공한다고 가정:
 * - buildStandaloneMockMvc(Object... controllers)
 * - loginAsUser()
 * - baseUrl, getRequest(String url)
 */
public class MxTrendControllerTest extends APIUnitExtension {

    @TestConfiguration
    @EnableGlobalMethodSecurity(prePostEnabled = true)
    public static class Config {
        @Bean
        public MxTrendController controller(MxTrendService service) {
            return new MxTrendController(service);
        }
        @Bean
        public MxTrendService service(MxMapper mapper) {
            return new MxTrendServiceImpl(mapper);
        }
    }

    @Autowired
    MxTrendController controller;

    @Autowired
    MxTrendService service;

    @MockBean
    MxMapper mapper;

    @BeforeEach
    void setUp() {
        buildStandaloneMockMvc(controller);
        loginAsUser();
    }

    @Test
    @DisplayName("GET /api/mx/trend 200")
    void getTrend_SHOULD_return_status_200_WHENEVER() throws Exception {
        String condition = "?departments=ASSY&departments=PACK&start=2025-01-01&end=2025-01-31";
        perform(getRequest(baseUrl + "/api/mx/trend" + condition))
                .andExpect(status().isOk());
    }

    @Test
    @DisplayName("GET /api/mx/trend 200 (단일 부서)")
    void getTrend_SINGLE_DEPT_SHOULD_return_status_200_WHENEVER() throws Exception {
        String condition = "?departments=ASSY&start=2025-02-01&end=2025-02-28";
        perform(getRequest(baseUrl + "/api/mx/trend" + condition))
                .andExpect(status().isOk());
    }
}