// week-utils.js
// 일요일 시작 + 전년도 포함 주차 유틸
// 규칙: 해당 연도의 1월 1일이 포함된 주의 일요일이 week1 시작일

import dayjs from 'dayjs'

/**
 * year의 week1 시작 일요일을 반환한다.
 * 규칙: 해당 연도의 1월 1일이 포함된 주의 일요일
 */
function getWeek1Sunday(year) {
  const januaryFirst = dayjs(`${year}-01-01`, 'YYYY-MM-DD')
  const weekday = januaryFirst.day()  // 0=Sun ~ 6=Sat
  return januaryFirst.subtract(weekday, 'day')
}

/**
 * 오늘 날짜가 해당 연도에서 몇 번째 Sunday-based week인지 반환한다.
 * (내부 전용 헬퍼)
 */
function getCurrentSundayBasedWeek(year) {
  const today = dayjs()
  const targetYear = year || today.year()

  const week1Sunday = getWeek1Sunday(targetYear)
  const daysSinceWeek1 = today.diff(week1Sunday, 'day')

  return Math.floor(daysSinceWeek1 / 7) + 1
}

export default {
  /**
   * 오늘까지의 Sunday-based week 배열을 반환한다.
   * 예: ['w1', 'w2', ..., 'w45']
   *
   * @param {number} year 기준 연도 (생략 시 today.year())
   * @returns {string[]} ['w1', 'w2', ...]
   */
  getSundayBasedWeeksUntilToday(year) {
    const currentYear = year || dayjs().year()
    const currentWeek = getCurrentSundayBasedWeek(currentYear)

    return Array.from(
      { length: currentWeek },
      (_, index) => `w${index + 1}`
    )
  },

  /**
   * 날짜 범위(시작일 ~ 종료일)에 포함되는 Sunday-based week 배열을 반환한다.
   * 예: ['w3', 'w4', 'w5']
   *
   * @param {number} year 기준 연도
   * @param {string} startDateStr 'YYYY-MM-DD'
   * @param {string} endDateStr   'YYYY-MM-DD'
   * @returns {string[]} ['wN', ...]
   */
  getSundayBasedWeeksInDateRange(year, startDateStr, endDateStr) {
    const startDate = dayjs(startDateStr, 'YYYY-MM-DD')
    const endDate = dayjs(endDateStr, 'YYYY-MM-DD')

    const week1Sunday = getWeek1Sunday(year)
    const matchedWeeks = []
    const maxWeeks = 60

    for (let index = 0; index < maxWeeks; index += 1) {
      const weekStart = week1Sunday.add(index * 7, 'day')
      const weekEnd = weekStart.add(6, 'day')

      const overlaps =
        weekEnd.isSameOrAfter(startDate, 'day') &&
        weekStart.isSameOrBefore(endDate, 'day')

      if (overlaps) {
        matchedWeeks.push(`w${index + 1}`)
      }
    }

    return matchedWeeks
  },

  /**
   * 주차 또는 주차 배열에 해당하는 전체 날짜 범위를 반환한다.
   * 예: { startDate: 'YYYY-MM-DD', endDate: 'YYYY-MM-DD' }
   *
   * @param {number} year 기준 연도
   * @param {string|string[]} weekInputs 'w3' 또는 ['w3', 'w4', ...]
   * @returns {{ startDate: string, endDate: string } | null}
   */
  getSundayBasedDateRangeForWeeks(year, weekInputs) {
    if (!weekInputs) {
      return null
    }

    const weekList = Array.isArray(weekInputs) ? weekInputs : [weekInputs]
    const week1Sunday = getWeek1Sunday(year)

    let minStart = null
    let maxEnd = null

    weekList.forEach((weekString) => {
      const weekNumber = parseInt(String(weekString).toLowerCase().replace('w', ''), 10)
      if (!weekNumber || weekNumber <= 0) {
        return
      }

      const weekStart = week1Sunday.add((weekNumber - 1) * 7, 'day')
      const weekEnd = weekStart.add(6, 'day')

      if (!minStart || weekStart.isBefore(minStart)) {
        minStart = weekStart
      }
      if (!maxEnd || weekEnd.isAfter(maxEnd)) {
        maxEnd = weekEnd
      }
    })

    if (!minStart || !maxEnd) {
      return null
    }

    return {
      startDate: minStart.format('YYYY-MM-DD'),
      endDate: maxEnd.format('YYYY-MM-DD')
    }
  }
}





ㅡㅡㅡㅡㅡㅡㅡㅡㅡ

자바용



package com.example.utils;

import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;

public class WeekUtils {

    /**
     * year의 week1 시작 일요일을 계산한다.
     * 규칙: 해당 연도의 1월 1일이 포함된 주의 '일요일'
     *
     * @param year 기준 연도
     * @return LocalDate 해당 연도 week1의 시작 일요일
     */
    private LocalDate getWeek1Sunday(int year) {
        LocalDate januaryFirst = LocalDate.of(year, 1, 1);

        // Java: Monday=1 ~ Sunday=7
        int dow = januaryFirst.getDayOfWeek().getValue();
        int sundayOffset = dow % 7; // Sunday → 0

        return januaryFirst.minusDays(sundayOffset);
    }

    /**
     * 오늘 날짜가 해당 연도에서 몇 번째 Sunday-based week인지 반환한다.
     * week1은 해당 연도의 1월 1일이 포함된 주의 일요일을 기준으로 계산된다.
     *
     * @param year optional (null이면 LocalDate.now().getYear() 사용)
     * @return int Sunday-based week index (1부터 시작)
     */
    public int getCurrentSundayBasedWeek(Integer year) {
        LocalDate today = LocalDate.now();
        int targetYear = (year == null ? today.getYear() : year);

        LocalDate week1Sunday = getWeek1Sunday(targetYear);
        long daysSinceWeek1 = ChronoUnit.DAYS.between(week1Sunday, today);

        return (int) (daysSinceWeek1 / 7) + 1;
    }

    /**
     * 오늘까지의 모든 Sunday-based week 목록을 반환한다.
     * 결과 예: ["w1", "w2", "w3", ..., "w46"]
     *
     * @param year optional (null이면 올해 사용)
     * @return List<String> "w1", "w2" ... 형태의 주차 리스트
     */
    public List<String> getSundayBasedWeeksUntilToday(Integer year) {
        int targetYear = (year == null ? LocalDate.now().getYear() : year);
        int currentWeek = getCurrentSundayBasedWeek(targetYear);

        List<String> weeks = new ArrayList<>();
        for (int i = 1; i <= currentWeek; i++) {
            weeks.add("w" + i);
        }
        return weeks;
    }

    /**
     * 날짜 범위가 포함하는 모든 Sunday-based week 문자열 목록을 반환한다.
     *
     * - 특정 날짜가 어느 주차에 속하는지 판정
     * - 범위에 걸친 모든 주차 반환
     * - 규칙: week1은 해당 연도 1월 1일이 포함된 주의 일요일 기준
     *
     * @param startDateStr "YYYY-MM-DD"
     * @param endDateStr   "YYYY-MM-DD"
     * @param year optional (null이면 startDateStr 기준의 연도 사용)
     * @return List<String> → ["w12", "w13", "w14"] 같은 주차 배열
     */
    public List<String> getSundayBasedWeeksInDateRange(String startDateStr,
                                                       String endDateStr,
                                                       Integer year) {

        LocalDate startDate = LocalDate.parse(startDateStr);
        LocalDate endDate = LocalDate.parse(endDateStr);

        int targetYear = (year == null ? startDate.getYear() : year);
        LocalDate week1Sunday = getWeek1Sunday(targetYear);

        List<String> matchedWeeks = new ArrayList<>();
        int maxWeeks = 60;

        for (int index = 0; index < maxWeeks; index++) {
            LocalDate weekStart = week1Sunday.plusDays(index * 7L);
            LocalDate weekEnd = weekStart.plusDays(6);

            boolean overlaps =
                !weekEnd.isBefore(startDate) &&
                !weekStart.isAfter(endDate);

            if (overlaps) {
                matchedWeeks.add("w" + (index + 1));
            }
        }
        return matchedWeeks;
    }

    /**
     * 여러 주차(wN → N)를 입력받아 해당되는 전체 날짜 범위를 반환한다.
     * 
     * 사용 예:
     *   ["w3", "w4"] → 3주차 시작일 ~ 4주차 종료일
     *
     * @param weekInputs ["w3"] 또는 ["w3","w4","w5"] 또는 단일 "w3" 도 가능
     * @param year optional (null이면 LocalDate.now().getYear())
     * @return DateRange { startDate: "YYYY-MM-DD", endDate: "YYYY-MM-DD" }
     */
    public DateRange getSundayBasedDateRangeForWeeks(List<String> weekInputs, Integer year) {

        if (weekInputs == null || weekInputs.isEmpty()) {
            return null;
        }

        int targetYear = (year == null ? LocalDate.now().getYear() : year);
        LocalDate week1Sunday = getWeek1Sunday(targetYear);

        LocalDate minStart = null;
        LocalDate maxEnd = null;

        for (String weekStr : weekInputs) {
            int weekNumber = Integer.parseInt(weekStr.toLowerCase().replace("w", ""));
            if (weekNumber <= 0) continue;

            LocalDate weekStart = week1Sunday.plusDays((weekNumber - 1L) * 7);
            LocalDate weekEnd = weekStart.plusDays(6);

            if (minStart == null || weekStart.isBefore(minStart)) {
                minStart = weekStart;
            }
            if (maxEnd == null || weekEnd.isAfter(maxEnd)) {
                maxEnd = weekEnd;
            }
        }

        if (minStart == null || maxEnd == null) {
            return null;
        }

        return new DateRange(minStart.toString(), maxEnd.toString());
    }

    /**
     * 날짜 범위를 담는 DTO
     *
     * @return startDate, endDate 두 값을 포함하는 단순 객체
     */
    public static class DateRange {
        public final String startDate;
        public final String endDate;

        public DateRange(String startDate, String endDate) {
            this.startDate = startDate;
            this.endDate = endDate;
        }
    }
}