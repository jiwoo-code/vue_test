<template>
  <v-chart
    class="sy-erlog-chart"
    :option="chartOption"
    :autoresize="true"
    @ready="onChartReady"
    @click="onChartClick"
  />
</template>

<script>
import { use, graphic } from 'echarts/core';
import { CanvasRenderer } from 'echarts/renderers';
import { CustomChart } from 'echarts/charts';
import { GridComponent, TooltipComponent, DataZoomComponent } from 'echarts/components';
import VChart from 'vue-echarts';

use([CanvasRenderer, CustomChart, GridComponent, TooltipComponent, DataZoomComponent]);

const COLOR_RULES = Object.freeze({
  hasSy: '#3b82f6',
  incompleteSy: '#f59e0b',
  reject: '#ef4444'
});

const TOOLTIP_TEXT_COLOR = Object.freeze({
  [COLOR_RULES.hasSy]: '#ffffff',
  [COLOR_RULES.incompleteSy]: '#111827',
  [COLOR_RULES.reject]: '#ffffff'
});

export default {
  name: 'SyErLogChart',
  components: {
    'v-chart': VChart
  },
  data() {
    return {
      chart: null,
      zr: null,
      zrGlobalOutHandler: null,
      items: [],
      categories: [],
      seriesData: [],
      domainStart: 0,
      domainEnd: 0
    };
  },
  beforeDestroy() {
    this.teardownChart();
  },
  computed: {
    chartOption() {
      const base = this.buildBaseOption();
      const dataZoom = base.dataZoom.map((item) => {
        if (item && item.id === 'erlog-slider') {
          return {
            ...item,
            startValue: this.domainStart,
            endValue: this.domainEnd
          };
        }
        return item;
      });
      const series = base.series.map((item) => {
        if (item && item.id === 'erlog-series') {
          return {
            ...item,
            data: this.seriesData
          };
        }
        return item;
      });

      return {
        ...base,
        xAxis: {
          ...base.xAxis,
          min: this.domainStart,
          max: this.domainEnd
        },
        yAxis: {
          ...base.yAxis,
          data: this.categories
        },
        dataZoom,
        series
      };
    }
  },
  methods: {
    // =====================
    // 차트 라이프사이클
    // =====================
    onChartReady(chart) {
      this.chart = chart;
      this.bindZrEvents();
    },
    teardownChart() {
      if (!this.chart) return;
      this.unbindZrEvents();
      this.hideTooltip();
      this.chart = null;
    },
    // =====================
    // 데이터 갱신
    // =====================
    setData(data) {
      this.items = Array.isArray(data) ? data : [];
      this.prepareSeries();
    },
    // =====================
    // 데이터 준비
    // =====================
    prepareSeries() {
      const categories = [];
      const seriesData = [];
      const categoryIndexMap = new Map();
      let minTime = null;
      let maxTime = null;

      this.items.forEach((item) => {
        if (!item) return;
        const eqpId = item.eqpId ?? 'EQP-UNKNOWN';
        let categoryIndex = categoryIndexMap.get(eqpId);
        if (categoryIndex == null) {
          categoryIndex = categories.length;
          categories.push(eqpId);
          categoryIndexMap.set(eqpId, categoryIndex);
        }

        const start = this.toTimeValue(item.lotStart);
        const end = this.toTimeValue(item.lotFinish);
        if (start == null || end == null) return;

        minTime = minTime == null ? start : Math.min(minTime, start);
        maxTime = maxTime == null ? end : Math.max(maxTime, end);

        const color = this.resolveColor(item);
        seriesData.push({
          name: item.lotId,
          value: [categoryIndex, start, end, Math.max(0, end - start)],
          itemStyle: {
            color
          },
          tooltipHtml: this.buildTooltipHtml(item, color),
          payload: {
            ...item
          }
        });
      });

      if (minTime == null || maxTime == null) {
        const now = Date.now();
        minTime = now - 60 * 60 * 1000;
        maxTime = now + 60 * 60 * 1000;
      }

      const padding = 20 * 60 * 1000;
      this.domainStart = minTime - padding;
      this.domainEnd = maxTime + padding;
      this.categories = categories;
      this.seriesData = seriesData;
    },
    resolveColor(item) {
      if (item.rejectWafer >= 1) {
        return COLOR_RULES.reject;
      }
      if (item.avgSyCount >= 63) {
        return COLOR_RULES.hasSy;
      }
      return COLOR_RULES.incompleteSy;
    },
    // =====================
    // 차트 옵션
    // =====================
    buildBaseOption() {
      return {
        backgroundColor: '#ffffff',
        animation: false,
        grid: {
          left: 80,
          right: 32,
          top: 20,
          bottom: 120
        },
        tooltip: {
          trigger: 'item',
          triggerOn: 'mousemove',
          confine: false,
          appendToBody: true,
          className: 'erlog-tooltip',
          backgroundColor: 'transparent',
          borderWidth: 0,
          padding: 0,
          showDelay: 0,
          hideDelay: 0,
          transitionDuration: 0,
          extraCssText: 'box-shadow: none; pointer-events: none;',
          position: (pos, params, dom, rect, size) =>
            this.getTooltipPosition(pos, size),
          formatter: this.getTooltipHtml
        },
        dataZoom: [
          {
            id: 'erlog-slider',
            type: 'slider',
            xAxisIndex: 0,
            filterMode: 'weakFilter',
            showDataShadow: false,
            brushSelect: false,
            bottom: 10,
            height: 22,
            labelFormatter: '',
            startValue: 0,
            endValue: 0
          },
          {
            id: 'erlog-inside',
            type: 'inside',
            xAxisIndex: 0,
            filterMode: 'weakFilter',
            zoomOnMouseWheel: true,
            moveOnMouseWheel: false,
            moveOnMouseMove: false
          }
        ],
        xAxis: {
          type: 'time',
          min: 0,
          max: 0,
          minInterval: 30 * 60 * 1000,
          splitNumber: 48,
          axisLine: {
            lineStyle: {
              color: '#cbd5e1'
            }
          },
          axisLabel: {
            color: '#475569',
            interval: 0,
            hideOverlap: true,
            rotate: 90,
            margin: 6,
            inside: false,
            formatter: (value) => this.formatAxisLabel(value)
          },
          splitLine: {
            show: true,
            lineStyle: {
              color: '#e2e8f0'
            }
          }
        },
        yAxis: {
          type: 'category',
          inverse: true,
          data: [],
          axisTick: { show: false },
          axisLine: { show: false },
          axisLabel: {
            color: '#334155'
          }
        },
        series: [
          {
            id: 'erlog-series',
            type: 'custom',
            renderItem: this.renderItem,
            itemStyle: {
              opacity: 0.92
            },
            encode: {
              x: [1, 2],
              y: 0
            },
            data: []
          }
        ]
      };
    },
    // =====================
    // 시리즈 렌더링
    // =====================
    renderItem(params, api) {
      const categoryIndex = api.value(0);
      const start = api.coord([api.value(1), categoryIndex]);
      const end = api.coord([api.value(2), categoryIndex]);
      const height = 35; // api.size([0, 1])[1] * 0.6;

      const rectShape = graphic.clipRectByRect(
        {
          x: start[0],
          y: start[1] - height / 2,
          width: end[0] - start[0],
          height
        },
        {
          x: params.coordSys.x,
          y: params.coordSys.y,
          width: params.coordSys.width,
          height: params.coordSys.height
        }
      );

      return (
        rectShape && {
          type: 'rect',
          transition: ['shape'],
          shape: rectShape,
          style: api.style()
        }
      );
    },
    // =====================
    // 차트 인터랙션
    // =====================
    onChartClick(params) {
      if (!params || params.seriesId !== 'erlog-series' || !params.data) return;
      const payload = params.data.payload;
      if (!payload) return;
      const clickedTime = this.getClickedTime(params);
      this.hideTooltip();
      console.log('아 이 미친새끼');
      this.$emit('select-lot', {
        lot: payload,
        clickedTime
      });
    },
    getClickedTime(params) {
      const data = params && params.data;
      const start = data && data.value ? data.value[1] : null;
      const end = data && data.value ? data.value[2] : null;

      if (!this.chart || !params || !params.event) {
        return start;
      }

      const offsetX = params.event.offsetX;
      const offsetY = params.event.offsetY;
      if (offsetX == null || offsetY == null) {
        return start;
      }

      const value = this.chart.convertFromPixel({ xAxisIndex: 0 }, [offsetX, offsetY]);
      const candidate = Array.isArray(value) ? value[0] : value;

      if (typeof candidate === 'number' && !Number.isNaN(candidate)) {
        if (start != null && end != null) {
          return Math.min(Math.max(candidate, start), end);
        }
        return candidate;
      }

      return start;
    },
    // =====================
    // 툴팁 헬퍼
    // =====================
    hideTooltip() {
      if (this.chart) {
        this.chart.dispatchAction({ type: 'hideTip' });
      }
      this.clearTooltip();
    },
    clearTooltip() {
      if (typeof document === 'undefined') return;
      const nodes = document.querySelectorAll(
        '.erlog-tooltip, .echarts-tooltip'
      );
      nodes.forEach((node) => {
        if (node && node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });
    },
    getTooltipHtml(params) {
      const data = params && params.data ? params.data : null;
      return data && data.tooltipHtml ? data.tooltipHtml : '';
    },
    buildTooltipHtml(item, color) {
      if (!item) return '';
      const textColor = TOOLTIP_TEXT_COLOR[color] || '#ffffff';
      const lines = [
        `Lot ID: ${this.safeText(item.lotId)}`,
        `Layer: ${this.safeText(item.layer)}`,
        `Device: ${this.safeText(item.device)}`,
        `Lot Start: ${this.safeText(item.lotStart)}`,
        `Lot Finish: ${this.safeText(item.lotFinish)}`,
        `Lot Size: ${this.safeText(item.lotSize)}`,
        `Reject Wafer: ${this.safeText(item.rejectWafer)}`
      ].join('<br/>');

      return [
        '<div style="',
        `background:${color};`,
        `color:${textColor};`,
        'padding:8px 10px;',
        'border-radius:8px;',
        'font-size:12px;',
        'line-height:1.5;',
        'box-shadow:0 10px 20px rgba(15,23,42,0.2);',
        '">',
        lines,
        '</div>'
      ].join('');
    },
    safeText(value) {
      return value == null ? '-' : String(value);
    },
    getTooltipPosition(pos, size) {
      if (!pos || !size || !Array.isArray(pos)) {
        return pos;
      }
      const margin = 8;
      const viewWidth = size.viewSize[0];
      const viewHeight = size.viewSize[1];
      const contentWidth = size.contentSize[0];
      const contentHeight = size.contentSize[1];

      let left = pos[0] + margin;
      let top = pos[1] - contentHeight - margin;

      if (top < margin) {
        top = pos[1] + margin;
      }
      if (left + contentWidth + margin > viewWidth) {
        left = viewWidth - contentWidth - margin;
      }
      if (left < margin) {
        left = margin;
      }
      if (top + contentHeight + margin > viewHeight) {
        top = viewHeight - contentHeight - margin;
      }
      if (top < margin) {
        top = margin;
      }

      return [left, top];
    },
    // =====================
    // ZRender 이벤트
    // =====================
    bindZrEvents() {
      if (!this.chart) return;
      const zr = this.chart.getZr();
      if (!zr) return;
      this.zr = zr;
      if (!this.zrGlobalOutHandler) {
        this.zrGlobalOutHandler = () => {
          this.hideTooltip();
        };
      }
      zr.on('globalout', this.zrGlobalOutHandler);
    },
    unbindZrEvents() {
      if (!this.zr) return;
      if (this.zrGlobalOutHandler) {
        this.zr.off('globalout', this.zrGlobalOutHandler);
      }
      this.zr = null;
    },
    // =====================
    // 포맷팅
    // =====================
    formatAxisLabel(value) {
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return '';
      return [
        `${this.pad2(date.getMonth() + 1)}-${this.pad2(date.getDate())}`,
        `${this.pad2(date.getHours())}:${this.pad2(date.getMinutes())}`
      ].join(' ');
    },
    pad2(value) {
      return String(value).padStart(2, '0');
    },
    // =====================
    // 시간 파싱
    // =====================
    toTimeValue(value) {
      if (value == null) return null;
      if (typeof value === 'number') return value;
      const parsed = this.parseDateTimeMs(value);
      if (parsed != null) return parsed;
      const time = new Date(value).getTime();
      return Number.isNaN(time) ? null : time;
    },
    parseDateTimeMs(value) {
      const match = /^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})\.(\d{3})$/.exec(
        String(value ?? '').trim()
      );
      if (!match) return null;
      const [, year, month, day, hour, minute, second, ms] = match;
      const date = new Date(
        Number(year),
        Number(month) - 1,
        Number(day),
        Number(hour),
        Number(minute),
        Number(second),
        Number(ms)
      );
      return Number.isNaN(date.getTime()) ? null : date.getTime();
    }
  }
};
</script>

<style scoped>
.sy-erlog-chart {
  width: 100%;
  height: 220px;
  border-radius: 14px;
  overflow: hidden;
  background: #ffffff;
  border: 1px solid rgba(15, 23, 42, 0.12);
}
</style>
