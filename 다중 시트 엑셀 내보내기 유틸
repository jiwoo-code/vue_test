
유틸 코드: excelExporter.js (브라우저 전용, Vue2 호환)
코드 복사
Javascript
// Imports
// 설치: npm i xlsx file-saver
import * as XLSX from 'xlsx';
import { saveAs } from 'file-saver';

/**
 * 시트명 유효화 (엑셀 제약: 31자, \ / ? * [ ] : 금지, 앞뒤 공백 제거)
 */
function sanitizeSheetName(name, index) {
  const raw = (name && String(name).trim()) || `Sheet${index + 1}`;
  const invalid = /[\\/?*\[\]:]/g;
  let safe = raw.replace(invalid, ' ');
  if (safe.length > 31) safe = safe.slice(0, 31);
  if (!safe) safe = `Sheet${index + 1}`;
  return safe;
}

/**
 * 워크북 생성
 * @param {Array<{sheetName: string, rows: Array<object>|Array<Array<any>>}>} sheets
 *  - rows: 객체 배열(JSON) 또는 2차원 배열(AOA) 모두 지원
 */
function buildWorkbook(sheets) {
  const wb = XLSX.utils.book_new();
  sheets.forEach((s, i) => {
    const name = sanitizeSheetName(s.sheetName, i);
    const rows = Array.isArray(s.rows) ? s.rows : [];
    const isAoa = Array.isArray(rows[0]);
    const ws = isAoa ? XLSX.utils.aoa_to_sheet(rows) : XLSX.utils.json_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, name);
  });
  return wb;
}

/**
 * 브라우저 저장 (파일명만 지정 가능, 경로/자동열기 불가)
 */
function saveInBrowser(wb, filename) {
  const out = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
  const blob = new Blob([out], { type: 'application/octet-stream' });
  saveAs(blob, filename);
}

/**
 * 엑셀 내보내기 함수 팩토리
 *
 * @param {Object} factoryOptions
 * @param {string} [factoryOptions.registerName] window에 등록할 함수명 (선택)
 * @returns {(sheets: Array<{sheetName:string, rows:any[]}>, opts?: {
 *   filename?: string  // 기본값: 'export.xlsx'
 * }) => Promise<void>}
 */
export function createExcelExporter(factoryOptions = {}) {
  /**
   * @param {Array<{sheetName:string, rows:any[]}>} sheets 시트 정의 배열 (필수)
   * @param {Object} opts 옵션
   * @param {string} [opts.filename='export.xlsx'] 파일명
   */
  async function exportExcel(sheets, opts = {}) {
    if (!Array.isArray(sheets) || sheets.length === 0) {
      throw new Error('sheets는 최소 1개 이상의 시트를 포함한 배열이어야 합니다.');
    }
    const filename = (opts.filename && String(opts.filename).trim()) || 'export.xlsx';
    const wb = buildWorkbook(sheets);
    saveInBrowser(wb, filename);
  }

  // 전역 등록(원하면 전역에서 window.내함수명(...) 호출)
  if (factoryOptions.registerName && typeof window !== 'undefined') {
    window[factoryOptions.registerName] = exportExcel;
  }

  return exportExcel;
}

/**
 * 기본 인스턴스
 * - import { exportExcel } from './excelExporter'
 * - 원하시는 이름으로 변수에 담아 사용 가능: const saveReport = exportExcel;
 */
export const exportExcel = createExcelExporter();
리팩토링 포인트(동작 동일)
isAoa 판별을 Array.isArray(rows[0])로 간결화.
rows 한 번만 안전 처리(Array.isArray(s.rows) ? s.rows : []).
불필요한 조건 분기/임시 변수 제거, I/O 경로 단일화로 가독성 ↑.
사용 예제 (복붙)
코드 복사
Javascript
// 1) 함수명을 내가 정해서 사용
// import { exportExcel } from './excelExporter';

const saveMultiSheet = exportExcel; // 필요 시 원하는 이름으로 대입
await saveMultiSheet(
  [
    { sheetName: '장비현황', rows: [{ eqpId: 'EQP-01', status: 'OK' }, { eqpId: 'EQP-02', status: 'NG' }] },
    { sheetName: 'RawData', rows: [['colA', 'colB'], [1, 2], [3, 4]] }
  ],
  { filename: 'monitoring.xlsx' }
);

// 2) 전역에 등록해서 호출
// import { createExcelExporter } from './excelExporter';
createExcelExporter({ registerName: 'saveAgGridExcel' });
// 이후 어디서든: window.saveAgGridExcel(sheets, { filename: 'report.xlsx' });
ag-Grid 데이터 뽑는 법 (복붙)
코드 복사
Javascript
// 표시 중인 행만 JSON으로 수집하는 간단 예시
function collectJsonFromAgGrid(gridApi) {
  const rows = [];
  gridApi.forEachNodeAfterFilterAndSort(node => {
    rows.push(node.data);
  });
  return rows;
}

// 사용
await exportExcel(
  [
    { sheetName: 'AG-Grid-1', rows: collectJsonFromAgGrid(gridApi1) },
    { sheetName: 'AG-Grid-2', rows: collectJsonFromAgGrid(gridApi2) }
  ],
  { filename: 'aggrid-export.xlsx' }
);
더 줄이고 싶으시면 말씀만 주세요.
예: 컬럼 순서 고정(AOA 변환), 헤더 한글변환/맵핑, 셀 너비 자동화 등 옵션도 얹어드릴게요











ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ


// ----------------------
// 상단 import
// ----------------------
import * as XLSX from 'xlsx';
import { saveAs } from 'file-saver';

// ----------------------
// 헬퍼 함수들 (export default 바깥에 선언)
// ----------------------

/**
 * 시트명 유효화 (엑셀 제약: 31자, \ / ? * [ ] : 금지, 앞뒤 공백 제거)
 */
function sanitizeSheetName(name, index) {
  const raw = (name && String(name).trim()) || `Sheet${index + 1}`;
  // ESLint: unnecessary escape character 경고 없이 안전한 문자 클래스
  const invalid = /[\\/?*[\]:]/g;
  let safe = raw.replace(invalid, ' ');
  if (safe.length > 31) safe = safe.slice(0, 31);
  if (!safe) safe = `Sheet${index + 1}`;
  return safe;
}

/**
 * 워크북 생성
 * @param {Array<{sheetName: string, rows: Array<object>|Array<Array<any>>}>} sheets
 *  - rows: 객체 배열(JSON) 또는 2차원 배열(AOA) 모두 지원
 */
function buildWorkbook(sheets) {
  const wb = XLSX.utils.book_new();
  sheets.forEach((s, i) => {
    const name = sanitizeSheetName(s.sheetName, i);
    const rows = Array.isArray(s.rows) ? s.rows : [];
    const isAoa = Array.isArray(rows[0]);
    const ws = isAoa ? XLSX.utils.aoa_to_sheet(rows) : XLSX.utils.json_to_sheet(rows);
    XLSX.utils.book_append_sheet(wb, ws, name);
  });
  return wb;
}

/**
 * 브라우저 저장 (파일명만 지정 가능, 경로/자동열기 불가)
 */
function saveInBrowser(wb, filename) {
  const out = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
  const blob = new Blob([out], { type: 'application/octet-stream' });
  saveAs(blob, filename);
}

// ----------------------
// export default (여기에 기존 유틸 메서드 + 엑셀 내보내기 추가)
// ----------------------
export default {
  exportCsv(content, fileName) {
    // ...
  },
  omit(obj, ...props) {
    // ...
  },
  averArr(arr) {
    // ...
  },

  // ✨ 새로 추가한 엑셀 내보내기 함수들 ✨
  
  /**
 * 엑셀 내보내기 함수 팩토리
 *
 * @param {Object} factoryOptions
 * @returns {(sheets: Array<{sheetName:string, rows:any[]}>, opts?: {
 *   filename?: string  // 기본값: 'export.xlsx'
 * }) => Promise<void>}
 */
createExcelExporter(factoryOptions = {}) {
  /**
   * @param {Array<{sheetName:string, rows:any[]}>} sheets 시트 정의 배열 (필수)
   * @param {Object} opts 옵션
   * @param {string} [opts.filename='export.xlsx'] 파일명
   */
  const exportExcel = async (sheets, opts = {}) => {
    if (!Array.isArray(sheets) || sheets.length === 0) {
      throw new Error('sheets는 최소 1개 이상의 시트를 포함한 배열이어야 합니다.');
      // 주석 유지: 시트 배열 입력, rows는 JSON 또는 2차원 배열 모두 가능
    }
    const filename = (opts.filename && String(opts.filename).trim()) || 'export.xlsx';
    const wb = buildWorkbook(sheets);
    saveInBrowser(wb, filename);
  };

  return exportExcel;
},

/**
 * 기본 인스턴스
 * - 원하시는 이름으로 변수에 담아 사용 가능: const saveReport = Util.exportExcel;
 * - import Util from '@/utils/Util' 후 Util.exportExcel(...) 형태로 바로 호출 가능
 */
async exportExcel(sheets, opts = {}) {
  if (!Array.isArray(sheets) || sheets.length === 0) {
    throw new Error('sheets는 최소 1개 이상의 시트를 포함한 배열이어야 합니다.');
  }
  const filename = (opts.filename && String(opts.filename).trim()) || 'export.xlsx';
  const wb = buildWorkbook(sheets);
  saveInBrowser(wb, filename);
}

/**
   * ag-Grid 데이터 추출
   * - 필터/정렬이 적용된 현재 표시 데이터만 반환
   * - exportExcel()의 rows에 바로 넣을 수 있는 배열 형태
   *
   * @param {object} gridApi ag-Grid의 gridApi 인스턴스
   * @param {boolean} [includeHiddenColumns=false] 숨김 컬럼도 포함할지 여부
   * @returns {Array<object>} rows 데이터 배열
   */
  getAgGridData(gridApi, includeHiddenColumns = false) {
    if (!gridApi) return [];

    const rows = [];
    const visibleColumns = gridApi
      .getColumnDefs()
      .filter(col => includeHiddenColumns || !col.hide)
      .map(col => col.field);

    gridApi.forEachNodeAfterFilterAndSort(node => {
      if (node.data) {
        // 필요한 컬럼만 추출
        const row = {};
        visibleColumns.forEach(field => {
          row[field] = node.data[field];
        });
        rows.push(row);
      }
    });

    return rows;
  },
};


ㅡㅡㅡㅡㅡㅡㅡㅡㅡ




  


/**
 * ag-Grid → AOA (컬럼 순서 보장, 컬럼 그룹 헤더 포함, '-' 헤더 컬럼 제외)
 *
 * @param {object} gridApi            ag-Grid gridApi
 * @param {object} columnApi          ag-Grid columnApi
 * @param {boolean} [reflectExpand=false]     컬럼 expand 상태 반영 여부(표시 컬럼만 쓸지)
 * @param {boolean} [reflectFilterSort=false] 필터/정렬 반영 여부(행 선택 방식)
 * @param {boolean} [applyValueFormatter=true] valueFormatter 적용 여부
 * @returns {Array<Array<any>>}       헤더 여러 행 + 데이터 행의 AOA
 */
getAgGridData(gridApi, columnApi, reflectExpand = false, reflectFilterSort = false, applyValueFormatter = true) {
  if (!gridApi || !columnApi) return [];

  // 1) 사용할 컬럼 목록 선택(표시 컬럼 vs 전체 컬럼)
  const cols = reflectExpand
    ? (columnApi.getAllDisplayedColumns ? columnApi.getAllDisplayedColumns() : [])
    : (columnApi.getColumns ? columnApi.getColumns() : []);

  // 2) 메타 구성(컬럼 그룹 경로, 헤더명), '-' 헤더 컬럼 제외
  const metas = cols.map(col => {
    const def = col.getColDef ? col.getColDef() : {};
    const colId = (col.getColId && col.getColId()) || def.colId || '';
    const header = def.headerName || colId || def.field || 'col';
    const groupPath = [];
    let parent = col.getParent ? col.getParent() : (col.getOriginalParent ? col.getOriginalParent() : null);
    while (parent && typeof parent.getColGroupDef === 'function') {
      const gdef = parent.getColGroupDef();
      const gname = gdef && (gdef.headerName || gdef.header);
      if (gname && gname !== '-') groupPath.unshift(String(gname));
      parent = parent.getParent ? parent.getParent() : null;
    }
    return { col, def, header, groupPath };
  }).filter(m => m.header !== '-');

  if (metas.length === 0) return [];

  // 3) 컬럼 그룹 헤더 행들 생성(최대 깊이만큼 여러 행)
  const maxDepth = metas.reduce((d, m) => Math.max(d, m.groupPath.length), 0);
  const headerRows = [];
  for (let level = 0; level < maxDepth; level += 1) {
    headerRows.push(metas.map(m => m.groupPath[level] || ''));
  }
  // 마지막 헤더 행(실제 컬럼 헤더)
  headerRows.push(metas.map(m => m.header));

  // 4) 셀 값 계산(valueGetter/valueFormatter 반영)
  const getValue = (node, { col, def }) => {
    let v = (typeof gridApi.getValue === 'function')
      ? gridApi.getValue(col, node)
      : (def.field && node.data ? node.data[def.field] : undefined);
    if (applyValueFormatter && typeof def.valueFormatter === 'function') {
      const p = { value: v ?? null, data: node.data, node, colDef: def, api: gridApi, columnApi, context: gridApi.context };
      const f = def.valueFormatter(p);
      if (f !== undefined && f !== null) v = f;
    }
    return v ?? '';
  };

  // 5) 행 순회(표시 행 → 필터/정렬 적용 행 → 전체 행)
  const aoa = [...headerRows];
  const pushData = node => {
    if (!node || node.group || node.footer) return; // 데이터 행만 수집
    aoa.push(metas.map(m => getValue(node, m)));
  };

  if (reflectFilterSort && reflectExpand && typeof gridApi.getDisplayedRowCount === 'function') {
    for (let i = 0, n = gridApi.getDisplayedRowCount(); i < n; i++) {
      pushData(gridApi.getDisplayedRowAtIndex(i));
    }
  } else if (reflectFilterSort && typeof gridApi.forEachNodeAfterFilterAndSort === 'function') {
    gridApi.forEachNodeAfterFilterAndSort(pushData);
  } else if (typeof gridApi.forEachNode === 'function') {
    gridApi.forEachNode(pushData);
  }

  return aoa;
}










/**
 * ag-Grid → AOA
 * (컬럼 순서 보장, 그룹 헤더 포함, '-' 헤더 컬럼 제외)
 *
 * @param {object} gridApi
 * @param {object} columnApi
 * @param {boolean} [reflectExpand=false]      표시 컬럼만 포함 여부
 * @param {boolean} [reflectFilterSort=false]  필터/정렬 반영 여부
 * @param {boolean} [applyValueFormatter=true] valueFormatter 적용 여부
 * @returns {Array<Array<any>>} 헤더 행 + 데이터 행의 AOA
 */
function getAgGridData(
  gridApi,
  columnApi,
  reflectExpand = false,
  reflectFilterSort = false,
  applyValueFormatter = true
) {
  if (!gridApi || !columnApi) return [];

  const EXCLUDE_HEADER = '-';

  // 안전 호출 유틸
  const safeCall = (obj, method, fallback) =>
    obj && typeof obj[method] === 'function' ? obj[method]() : fallback;

  // 상위 그룹 경로 구성
  const buildGroupPath = (col) => {
    const path = [];
    let parent = safeCall(col, 'getParent', null) || safeCall(col, 'getOriginalParent', null);
    while (parent && typeof parent.getColGroupDef === 'function') {
      const gdef = parent.getColGroupDef();
      const name = gdef && (gdef.headerName || gdef.header);
      if (name && name !== EXCLUDE_HEADER) path.unshift(String(name));
      parent = safeCall(parent, 'getParent', null);
    }
    return path;
  };

  // 셀 값 계산 (valueGetter/valueFormatter 반영)
  const getCellValue = (node, meta) => {
    const { col, def } = meta;
    let value = typeof gridApi.getValue === 'function'
      ? gridApi.getValue(col, node)
      : def.field && node?.data ? node.data[def.field] : undefined;

    if (applyValueFormatter && typeof def.valueFormatter === 'function') {
      const params = {
        value: value ?? null,
        data: node?.data,
        node,
        colDef: def,
        column: col,
        api: gridApi,
        columnApi,
        context: gridApi.context
      };
      const formatted = def.valueFormatter(params);
      if (formatted != null) value = formatted;
    }
    return value ?? '';
  };

  // 컬럼 메타 구성
  const columns = reflectExpand
    ? safeCall(columnApi, 'getAllDisplayedColumns', [])
    : safeCall(columnApi, 'getColumns', []);

  const metas = columns
    .map(col => {
      const def = safeCall(col, 'getColDef', {}) || {};
      const colId = safeCall(col, 'getColId', null) || def.colId || '';
      const header = def.headerName || colId || def.field || 'col';
      return { col, def, header, groupPath: buildGroupPath(col) };
    })
    .filter(m => m.header !== EXCLUDE_HEADER);

  if (metas.length === 0) return [];

  // 그룹 헤더 행 생성
  const maxDepth = Math.max(0, ...metas.map(m => m.groupPath.length));
  const headerRows = Array.from({ length: maxDepth }, (_, level) =>
    metas.map(m => m.groupPath[level] || '')
  );
  headerRows.push(metas.map(m => m.header)); // 실제 헤더 행 추가

  // 데이터 행 구성
  const aoa = [...headerRows];
  const collectNode = (node) => {
    if (node && !node.group && !node.footer) {
      aoa.push(metas.map(m => getCellValue(node, m)));
    }
  };

  // 행 순회 전략
  if (reflectFilterSort && reflectExpand && typeof gridApi.getDisplayedRowCount === 'function') {
    for (let i = 0, n = gridApi.getDisplayedRowCount(); i < n; i++) {
      collectNode(gridApi.getDisplayedRowAtIndex(i));
    }
  } else if (reflectFilterSort && typeof gridApi.forEachNodeAfterFilterAndSort === 'function') {
    gridApi.forEachNodeAfterFilterAndSort(collectNode);
  } else if (typeof gridApi.forEachNode === 'function') {
    gridApi.forEachNode(collectNode);
  }

  return aoa;
}










/**
 * ag-Grid → AOA (Array of Arrays)
 * (컬럼 순서 보장, 그룹 헤더 포함, '-' 헤더 컬럼 제외)
 *
 * @param {object} gridApi - ag-Grid gridApi
 * @param {object} columnApi - ag-Grid columnApi
 * @param {boolean} [reflectExpand=false] - 표시 컬럼만 포함 여부
 * @param {boolean} [reflectFilterSort=false] - 필터/정렬 반영 여부
 * @param {boolean} [applyValueFormatter=true] - valueFormatter 적용 여부
 * @returns {Array<Array<any>>} 헤더 행 + 데이터 행의 AOA
 */
function getAgGridData(
  gridApi,
  columnApi,
  reflectExpand = false,
  reflectFilterSort = false,
  applyValueFormatter = true
) {
  if (!gridApi || !columnApi) return [];

  const EXCLUDE_HEADER = '-';

  // --- 헬퍼 함수 ---

  /**
   * 객체의 메서드를 안전하게 호출합니다.
   * @param {object} obj - 대상 객체
   * @param {string} methodName - 호출할 메서드 이름
   * @param {any} fallback - 메서드 호출 실패 시 반환할 값
   */
  const safeCall = (obj, methodName, fallback = null) => {
    return (obj && typeof obj[methodName] === 'function')
      ? obj[methodName]()
      : fallback;
  };

  /**
   * 컬럼의 상위 그룹 경로를 배열로 수집합니다. (예: ['상위그룹', '하위그룹'])
   */
  function buildGroupPath(col) {
    const path = [];
    let parent =
      safeCall(col, 'getParent', null) ||
      safeCall(col, 'getOriginalParent', null);

    while (parent && typeof parent.getColGroupDef === 'function') {
      const gdef = parent.getColGroupDef();
      const name = gdef && (gdef.headerName || gdef.header);
      if (name && name !== EXCLUDE_HEADER) path.unshift(String(name));
      parent = safeCall(parent, 'getParent', null);
    }
    return path;
  }

  /**
   * 셀의 최종 표시 값을 계산합니다. (valueGetter/field → valueFormatter)
   * @param {object} node - ag-Grid rowNode
   * @param {object} meta - { col, def }를 포함한 메타 객체
   */
  function getCellValue(node, { col, def }) { // <-- 1. 구조 분해 할당
    const data = node?.data;
    let value = (typeof gridApi.getValue === 'function')
      ? gridApi.getValue(col, node)
      : (def.field && data ? data[def.field] : undefined);

    if (applyValueFormatter && def && typeof def.valueFormatter === 'function') {
      const params = {
        value: value ?? null, // <-- 2. nullish coalescing (??) 사용
        data: data,
        node: node,
        colDef: def,
        column: col,
        api: gridApi,
        columnApi: columnApi,
        context: gridApi.context
      };
      const formatted = def.valueFormatter(params);
      if (formatted != null) value = formatted;
    }
    // null 또는 undefined는 빈 문자열로 반환
    return value == null ? '' : value;
  }

  /**
   * 데이터 행인지 확인합니다. (그룹/푸터 제외)
   */
  const isDataNode = (node) => !!node && !node.group && !node.footer;

  /**
   * AOA 배열에 데이터 노드를 추가합니다.
   */
  function collectNode(node) {
    if (!isDataNode(node)) return;
    aoa.push(metas.map(m => getCellValue(node, m)));
  }

  // --- 메인 로직 ---

  // 1) 사용할 컬럼(표시 vs 전체)
  const columns = reflectExpand
    ? safeCall(columnApi, 'getAllDisplayedColumns', [])
    : safeCall(columnApi, 'getColumns', []);

  // 2) 메타 구성(그룹 경로/헤더) 후 '-' 헤더 제외
  const metas = columns.map(col => {
    const def = safeCall(col, 'getColDef', {}); // <-- 3. 불필요한 '|| {}' 제거
    const colId = safeCall(col, 'getColId', null) || def.colId || '';
    const header = def.headerName || colId || def.field || 'col';
    return { col: col, def: def, header: header, groupPath: buildGroupPath(col) };
  }).filter(m => m.header !== EXCLUDE_HEADER);

  if (metas.length === 0) return [];

  // 3) 그룹 헤더 행(최대 깊이만큼) + 실제 헤더 행
  const maxDepth = Math.max(0, ...metas.map(m => m.groupPath.length));
  const headerRows = Array.from({ length: maxDepth }, (_, level) =>
    metas.map(m => m.groupPath[level] || '')
  );
  headerRows.push(metas.map(m => m.header));

  // 4) 데이터 행 수집
  const aoa = [...headerRows];

  // 5) 순회 전략(표시 행 → 필터/정렬 → 전체)
  if (reflectFilterSort && reflectExpand && typeof gridApi.getDisplayedRowCount === 'function') {
    for (let i = 0, n = gridApi.getDisplayedRowCount(); i < n; i++) {
      collectNode(gridApi.getDisplayedRowAtIndex(i));
    }
  } else if (reflectFilterSort && typeof gridApi.forEachNodeAfterFilterAndSort === 'function') {
    gridApi.forEachNodeAfterFilterAndSort(collectNode);
  } else if (typeof gridApi.forEachNode === 'function') {
    gridApi.forEachNode(collectNode);
  }

  return aoa;
}

