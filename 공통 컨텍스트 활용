package com.example.mx.application;

import com.example.mx.domain.MxHistoryRow;
import lombok.Getter;
import lombok.Setter;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class MxTrendServiceImpl implements MxTrendService {

    private final MxMapper mxMapper;

    public MxTrendServiceImpl(MxMapper mxMapper) {
        this.mxMapper = mxMapper;
    }

    // =====================================================
    //                    Public APIs
    // =====================================================

    /**
     * 1. ì „ì²´ íŠ¸ë Œë“œ í…Œì´ë¸” ìƒì„± (ì—´ + í–‰ ëª¨ë‘ ì¶”ê°€)
     * - ì—´: EQPë³„ ê°’ + rowSum(í•­ëª©ë³„ ALL) + daySec + dayMin
     * - í–‰: ì¼ë°˜ action/component í–‰ + sum + dailyMActionCount + mxPerDayMin
     */
    @Override
    public List<Map<String, Object>> buildTrend(List<String> departments, String startDate, String endDate) {
        TrendContext trendContext = createContext(departments, startDate, endDate);
        if (trendContext == null) {
            return Collections.emptyList();
        }

        // 1) ê¸°ë³¸ í…Œì´ë¸” ìƒì„± (ActionName, component, eqpId ì»¬ëŸ¼)
        // 2) ì—´ ë ë©”íŠ¸ë¦­(rowSum, daySec, dayMin) + í•©ê³„í–‰(sum) ê³„ì‚°
        addSumRow(trendContext);            // ì„¤ë¹„ë³„ í•©ê³„í–‰(ì—´ ë°©í–¥ í•©ê³„): ActionName = "sum"
        addRowSum(trendContext);            // ê° í–‰ì˜ í•©ê³„(í–‰ ë°©í–¥ í•©ê³„) â†’ rowSum
        calculateDailyCounts(trendContext); // Daily_MAction ìˆ˜(ì„¤ë¹„ë³„, ì „ì²´) ì§‘ê³„
        addDaySecAndDayMin(trendContext);   // daySec, dayMin ê³„ì‚°

        // 3) í–‰ ë ë©”íŠ¸ë¦­ í–‰ë“¤ ì¶”ê°€ (dailyMActionCount, mxPerDayMin)
        addExtraMetricRows(trendContext);   // sum í–‰ì€ ì´ë¯¸ ì¶”ê°€ë¨

        // 4) ë°˜ì˜¬ë¦¼ ì ìš© (ì—´ ë©”íŠ¸ë¦­ í¬í•¨, yearWeekëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
        return finalizeRounded(trendContext, true, false);
    }

    /**
     * 2. ì£¼ì°¨ ë‹¨ìœ„ íŠ¸ë Œë“œ í…Œì´ë¸” (ì—´ë§Œ ì¶”ê°€ + ì—°ë„+ì£¼ì°¨ í¬í•¨)
     * - ì—´: EQPë³„ ê°’ + rowSum + daySec + dayMin + yearWeek
     * - í–‰: ì¼ë°˜ action/component í–‰ë§Œ ì‚¬ìš© (sum, dailyMActionCount, mxPerDayMin ì—†ìŒ)
     */
    @Override
    public List<Map<String, Object>> buildWeeklyTrendColumns(
        List<String> departments,
        String startDate,
        String endDate,
        String yearWeek
    ) {
        TrendContext trendContext = createContext(departments, startDate, endDate);
        if (trendContext == null) {
            return Collections.emptyList();
        }

        addRowSum(trendContext);            // ê° í–‰ì˜ í•©ê³„(í–‰ ë°©í–¥ í•©ê³„) â†’ rowSum
        calculateDailyCounts(trendContext); // Daily_MAction ìˆ˜(ì„¤ë¹„ë³„, ì „ì²´) ì§‘ê³„
        addDaySecAndDayMin(trendContext);   // daySec, dayMin ê³„ì‚°
        addYearWeek(trendContext, yearWeek);

        // ì—´ ë©”íŠ¸ë¦­ í¬í•¨, yearWeek í¬í•¨, í–‰ ë©”íŠ¸ë¦­ í–‰ë“¤ì€ ì¶”ê°€í•˜ì§€ ì•ŠìŒ
        return finalizeRounded(trendContext, true, true);
    }

    /**
     * 3. ì£¼ì°¨ ë‹¨ìœ„ íŠ¸ë Œë“œ í…Œì´ë¸” (í–‰ë§Œ ì¶”ê°€ + ì—°ë„+ì£¼ì°¨ í¬í•¨)
     * - ì—´: EQPë³„ ê°’ + yearWeek
     * - í–‰: ì¼ë°˜ action/component í–‰ + sum + dailyMActionCount + mxPerDayMin
     *   (rowSum, daySec, dayMin ì»¬ëŸ¼ì€ ë§Œë“¤ì§€ ì•ŠìŒ)
     */
    @Override
    public List<Map<String, Object>> buildWeeklyTrendRows(
        List<String> departments,
        String startDate,
        String endDate,
        String yearWeek
    ) {
        TrendContext trendContext = createContext(departments, startDate, endDate);
        if (trendContext == null) {
            return Collections.emptyList();
        }

        // í–‰ ë©”íŠ¸ë¦­ ê³„ì‚°ì— í•„ìš”í•œ ê²ƒë§Œ ìˆ˜í–‰
        addSumRow(trendContext);            // ì„¤ë¹„ë³„ í•©ê³„í–‰(ì—´ ë°©í–¥ í•©ê³„)
        calculateDailyCounts(trendContext); // Daily_MAction ìˆ˜(ì„¤ë¹„ë³„, ì „ì²´) ì§‘ê³„
        addExtraMetricRows(trendContext);   // dailyMActionCount, mxPerDayMin í–‰ ì¶”ê°€
        addYearWeek(trendContext, yearWeek);

        // ì—´ ë©”íŠ¸ë¦­(rowSum, daySec, dayMin)ì€ í¬í•¨í•˜ì§€ ì•Šê³ , yearWeekë§Œ í¬í•¨
        return finalizeRounded(trendContext, false, true);
    }

    // =====================================================
    //                 Internal Helper Methods
    // =====================================================

    /**
     * ê³µí†µ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
     * - departments, ê¸°ê°„ ì¡°ê±´ìœ¼ë¡œ mxHistories ì¡°íšŒ
     * - EQP ëª©ë¡ ì¶”ì¶œ
     * - í”¼ë²— ìƒì„±
     * - ê¸°ë³¸ í…Œì´ë¸” ìƒì„± (ActionName, component, eqpId ì»¬ëŸ¼)
     */
    private TrendContext createContext(List<String> departments, String startDate, String endDate) {
        if (departments == null || departments.isEmpty()) {
            return null;
        }

        List<MxHistoryRow> mxHistories =
            mxMapper.getAllMxHistoryByDepartments(departments, startDate, endDate);
        if (mxHistories == null || mxHistories.isEmpty()) {
            return null;
        }

        List<String> eqpIds = extractEqpIds(mxHistories);
        Map<String, Map<String, Double>> pivot = buildPivot(mxHistories);
        List<Map<String, Object>> table = buildBaseTable(pivot, eqpIds);

        return new TrendContext(mxHistories, eqpIds, table);
    }

    // EQP ì»¬ëŸ¼ ëª©ë¡: DB ë“±ì¥ ìˆœì„œ ìœ ì§€ + ì¤‘ë³µ ì œê±°
    private List<String> extractEqpIds(List<MxHistoryRow> mxHistories) {
        return mxHistories.stream()
            .map(MxHistoryRow::getEqpId)
            .filter(Objects::nonNull)
            .distinct()
            .collect(Collectors.toList());
    }

    // í”¼ë²— êµ¬ì¡° ë§Œë“¤ê¸° (actionName+component ì¡°í•©ë³„ ì„¤ë¹„ë³„ mxSeconds í•©ê³„ ê³„ì‚°)
    // key: "actionName|component", value: (eqpId â†’ sum(mxSeconds))
    private Map<String, Map<String, Double>> buildPivot(List<MxHistoryRow> mxHistories) {
        Map<String, Map<String, Double>> pivot = new LinkedHashMap<>();

        for (MxHistoryRow mxHistoryRow : mxHistories) {
            String actionName = mxHistoryRow.getActionName();
            String component = mxHistoryRow.getComponent() == null ? "" : mxHistoryRow.getComponent();
            String pivotKey = actionName + "|" + component;

            Map<String, Double> equipmentSums = pivot.computeIfAbsent(pivotKey, key -> new LinkedHashMap<>());
            equipmentSums.merge(mxHistoryRow.getEqpId(), mxHistoryRow.getMxSeconds(), Double::sum);
        }

        return pivot;
    }

    // í”¼ë²—ì„ ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ë³€í™˜
    // - í–‰: ActionName, component, ê° eqpId ì»¬ëŸ¼
    // - ê°’ì´ ì—†ìœ¼ë©´ null (ë¹ˆ ì…€ë¡œ ì‚¬ìš©)
    // - ActionName ê¸°ì¤€ ì •ë ¬
    private List<Map<String, Object>> buildBaseTable(
        Map<String, Map<String, Double>> pivot,
        List<String> eqpIds
    ) {
        List<Map<String, Object>> table = new ArrayList<>();

        for (Map.Entry<String, Map<String, Double>> pivotEntry : pivot.entrySet()) {
            String pivotKey = pivotEntry.getKey();
            int separatorIndex = pivotKey.indexOf('|');
            String actionName = separatorIndex >= 0 ? pivotKey.substring(0, separatorIndex) : pivotKey;
            String component = separatorIndex >= 0 ? pivotKey.substring(separatorIndex + 1) : "";

            Map<String, Double> equipmentSums = pivotEntry.getValue();

            Map<String, Object> rowMap = new LinkedHashMap<>();
            rowMap.put("ActionName", actionName);
            rowMap.put("component", component);

            for (String eqpId : eqpIds) {
                rowMap.put(eqpId, equipmentSums.containsKey(eqpId) ? equipmentSums.get(eqpId) : null);
            }
            table.add(rowMap);
        }

        // actionName ê¸°ì¤€ìœ¼ë¡œ ì¬ì •ë ¬
        table.sort(Comparator.comparing(
            row -> ((String) row.get("ActionName")).toLowerCase(),
            Comparator.nullsLast(String::compareTo)
        ));

        return table;
    }

    // ì„¤ë¹„ë³„ í•©ê³„í–‰(ì—´ ë°©í–¥ í•©ê³„) ì¶”ê°€: ActionName = "sum"
    private void addSumRow(TrendContext trendContext) {
        List<String> eqpIds = trendContext.getEqpIds();
        List<Map<String, Object>> table = trendContext.getTable();

        Map<String, Object> equipmentTotalsRow = new LinkedHashMap<>();
        equipmentTotalsRow.put("ActionName", "sum");
        equipmentTotalsRow.put("component", null);

        for (String eqpId : eqpIds) {
            double columnSum = table.stream()
                .mapToDouble(row -> toDoubleOrZero(row.get(eqpId)))
                .sum();
            equipmentTotalsRow.put(eqpId, columnSum);
        }

        table.add(equipmentTotalsRow);
        trendContext.setEquipmentTotalsRow(equipmentTotalsRow);
    }

    // null â†’ 0.0, Number â†’ double, ê·¸ ì™¸ â†’ 0.0 (í•©ê³„ ê³„ì‚°ìš©)
    private double toDoubleOrZero(Object value) {
        return (value instanceof Number) ? ((Number) value).doubleValue() : 0.0;
    }

    // ê° í–‰ì˜ í•©ê³„(í–‰ ë°©í–¥ í•©ê³„) â†’ rowSum
    private void addRowSum(TrendContext trendContext) {
        List<String> eqpIds = trendContext.getEqpIds();
        List<Map<String, Object>> table = trendContext.getTable();

        for (Map<String, Object> row : table) {
            double rowSum = eqpIds.stream()
                .mapToDouble(eqpId -> toDoubleOrZero(row.get(eqpId)))
                .sum();
            row.put("rowSum", rowSum);
        }
    }

    // Daily_MAction ìˆ˜(ì„¤ë¹„ë³„ count) ì§‘ê³„
    private void calculateDailyCounts(TrendContext trendContext) {
        Map<String, Long> dailyCountByEqp = trendContext.getMxHistories().stream()
            .filter(mxHistoryRow -> "Daily_MAction".equals(mxHistoryRow.getActionName()))
            .collect(Collectors.groupingBy(
                MxHistoryRow::getEqpId,
                LinkedHashMap::new,
                Collectors.counting()
            ));

        long dailyTotalCount = dailyCountByEqp.values().stream()
            .mapToLong(Long::longValue)
            .sum();

        trendContext.setDailyCountByEqp(dailyCountByEqp);
        trendContext.setDailyTotalCount(dailyTotalCount);
    }

    // daySec, dayMin ê³„ì‚° (ë¶„ëª¨ 0 ë³´í˜¸)
    // - daySec = rowSum / dailyTotalCount
    // - dayMin = daySec / 60
    private void addDaySecAndDayMin(TrendContext trendContext) {
        List<Map<String, Object>> table = trendContext.getTable();
        long dailyTotalCount = trendContext.getDailyTotalCount();

        double denominator = (dailyTotalCount == 0L) ? 1.0 : (double) dailyTotalCount;

        for (Map<String, Object> row : table) {
            double rowSum = toDoubleOrZero(row.get("rowSum"));
            row.put("daySec", rowSum / denominator);
            row.put("dayMin", (rowSum / denominator) / 60.0);
        }
    }

    // sum, dailyMActionCount, mxPerDayMin í–‰ ì¶”ê°€
    // - sum í–‰ì€ addSumRowì—ì„œ ì´ë¯¸ ì¶”ê°€
    // - ì—¬ê¸°ì„œëŠ” dailyMActionCount, mxPerDayMin ë‘ í–‰ë§Œ ì¶”ê°€
    private void addExtraMetricRows(TrendContext trendContext) {
        List<String> eqpIds = trendContext.getEqpIds();
        List<Map<String, Object>> table = trendContext.getTable();
        Map<String, Object> equipmentTotalsRow = trendContext.getEquipmentTotalsRow();
        Map<String, Long> dailyCountByEqp = trendContext.getDailyCountByEqp();

        // Daily_MAction ìˆ˜(ì„¤ë¹„ë³„ count) í–‰: ActionName = "dailyMActionCount"
        Map<String, Object> dailyCountRow = new LinkedHashMap<>();
        dailyCountRow.put("ActionName", "dailyMActionCount");
        dailyCountRow.put("component", null);

        long dailyRowSum = 0L;
        for (String eqpId : eqpIds) {
            long count = dailyCountByEqp.getOrDefault(eqpId, 0L);
            dailyCountRow.put(eqpId, count);
            dailyRowSum += count;
        }
        dailyCountRow.put("rowSum", dailyRowSum);
        dailyCountRow.put("daySec", null);
        dailyCountRow.put("dayMin", null);

        // MX/day(min) í–‰: ì„¤ë¹„í•© / ì„¤ë¹„ë³„ daily count / 60
        Map<String, Object> mxPerDayMinRow = new LinkedHashMap<>();
        mxPerDayMinRow.put("ActionName", "mxPerDayMin");
        mxPerDayMinRow.put("component", null);

        double mxDayMinTotal = 0.0;
        for (String eqpId : eqpIds) {
            double equipmentSum = toDoubleOrZero(equipmentTotalsRow.get(eqpId));
            long dailyCount = ((Number) dailyCountRow.getOrDefault(eqpId, 0L)).longValue();
            double value = (dailyCount == 0L) ? 0.0 : (equipmentSum / dailyCount / 60.0);
            mxPerDayMinRow.put(eqpId, value);
            mxDayMinTotal += value;
        }
        mxPerDayMinRow.put("rowSum", mxDayMinTotal);
        mxPerDayMinRow.put("daySec", null);
        mxPerDayMinRow.put("dayMin", null);

        table.add(dailyCountRow);
        table.add(mxPerDayMinRow);
    }

    // ëª¨ë“  í–‰ì— yearWeek ì»¬ëŸ¼ ì¶”ê°€
    private void addYearWeek(TrendContext trendContext, String yearWeek) {
        if (yearWeek == null) {
            return;
        }
        for (Map<String, Object> row : trendContext.getTable()) {
            row.put("yearWeek", yearWeek);
        }
    }

    // ì†Œìˆ˜ì  4ìë¦¬ ë°˜ì˜¬ë¦¼
    private double round4(double value) {
        return Math.round(value * 10000.0) / 10000.0;
    }

    // ì¶œë ¥ìš© ë°˜ì˜¬ë¦¼ ê·œì¹™
    // - null â†’ null
    // - Integer/Long â†’ ê·¸ëŒ€ë¡œ ìœ ì§€
    // - Number â†’ round4
    // - ê·¸ ì™¸ â†’ ê·¸ëŒ€ë¡œ
    private Object roundForDisplay(Object value) {
        if (value == null) {
            return null;
        }
        if (value instanceof Integer || value instanceof Long) {
            return value;
        }
        if (value instanceof Number) {
            return round4(((Number) value).doubleValue());
        }
        return value;
    }

    /**
     * ìµœì¢… ê²°ê³¼ êµ¬ì„±
     * - includeColumnMetrics: rowSum / daySec / dayMin ì»¬ëŸ¼ í¬í•¨ ì—¬ë¶€
     * - includeYearWeek: yearWeek ì»¬ëŸ¼ í¬í•¨ ì—¬ë¶€
     */
    private List<Map<String, Object>> finalizeRounded(
        TrendContext trendContext,
        boolean includeColumnMetrics,
        boolean includeYearWeek
    ) {
        List<String> eqpIds = trendContext.getEqpIds();
        List<Map<String, Object>> table = trendContext.getTable();

        List<Map<String, Object>> result = new ArrayList<>();

        for (Map<String, Object> row : table) {
            Map<String, Object> outputRow = new LinkedHashMap<>();
            outputRow.put("ActionName", row.get("ActionName"));
            outputRow.put("component", row.get("component"));

            for (String eqpId : eqpIds) {
                outputRow.put(eqpId, roundForDisplay(row.get(eqpId)));
            }

            if (includeColumnMetrics) {
                outputRow.put("rowSum", roundForDisplay(row.get("rowSum")));
                outputRow.put("daySec", roundForDisplay(row.get("daySec")));
                outputRow.put("dayMin", roundForDisplay(row.get("dayMin")));
            }

            if (includeYearWeek && row.containsKey("yearWeek")) {
                outputRow.put("yearWeek", row.get("yearWeek"));
            }

            result.add(outputRow);
        }

        return result;
    }

    // =====================================================
    //                 TrendContext (Internal)
    // =====================================================

    /**
     * ê³µí†µ ê³„ì‚°ì— ì‚¬ìš©í•˜ëŠ” ì»¨í…ìŠ¤íŠ¸
     * - mxHistories, eqpIds, tableì€ ìƒì„± ì‹œ ê³ ì •
     * - dailyCountByEqp, dailyTotalCount, equipmentTotalsRowëŠ” ê³„ì‚° ë‹¨ê³„ì—ì„œ ì±„ì›€
     */
    @Getter
    @Setter
    private class TrendContext {
        private List<MxHistoryRow> mxHistories;
        private List<String> eqpIds;
        private List<Map<String, Object>> table;

        private Map<String, Long> dailyCountByEqp;
        private long dailyTotalCount;
        private Map<String, Object> equipmentTotalsRow;

        public TrendContext(
            List<MxHistoryRow> mxHistories,
            List<String> eqpIds,
            List<Map<String, Object>> table
        ) {
            this.mxHistories = mxHistories;
            this.eqpIds = eqpIds;
            this.table = table;
        }
    }
}



















/**
 * ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ì •ë ¬ í•¨ìˆ˜
 * - yearWeekê°€ ìˆìœ¼ë©´: actionName â†’ component â†’ yearWeek ìˆœ
 * - yearWeekê°€ ì—†ìœ¼ë©´: actionName â†’ component ìˆœ
 */
private List<Map<String, Object>> sortTrendRows(List<Map<String, Object>> rows) {

    if (rows == null || rows.isEmpty()) {
        return rows;
    }

    boolean hasYearWeek = rows.stream().anyMatch(row -> row.get("yearWeek") != null);

    // ê³µí†µ comparator: actionName â†’ component
    Comparator<Map<String, Object>> baseComparator =
        Comparator.<Map<String, Object>, String>comparing(
                row -> (String) row.get("actionName"),
                Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER)
        ).thenComparing(
                row -> (String) row.get("component"),
                Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER)
        );

    if (hasYearWeek) {
        // yearWeekê¹Œì§€ ì¶”ê°€ ì •ë ¬
        baseComparator = baseComparator.thenComparing(
                row -> (String) row.get("yearWeek"),
                Comparator.nullsLast(String::compareTo)
        );
    }

    rows.sort(baseComparator);
    return rows;
}














/**
 * ê³µí†µ TrendContextë¥¼ ê¸°ë°˜ìœ¼ë¡œ, tableë§Œ ê¹Šì€ ë³µì‚¬ë¥¼ í•´ì„œ
 * ë…ë¦½ì ìœ¼ë¡œ ê°€ê³µí•  ìˆ˜ ìˆëŠ” ë³µì‚¬ ì»¨í…ìŠ¤íŠ¸ë¥¼ ìƒì„±í•œë‹¤.
 */
private TrendContext copyContext(TrendContext baseContext) {
    if (baseContext == null) {
        return null;
    }

    // mxHistories, eqpIdsëŠ” ì½ê¸° ì „ìš©ì´ë¯€ë¡œ ê³µìœ í•´ë„ OK
    List<MxHistoryRow> mxHistories = baseContext.getMxHistories();
    List<String> eqpIds = baseContext.getEqpIds();

    // tableì€ ê° ë²„ì „ì—ì„œ ê°€ê³µ(addSumRow, addSumCol, addExtraMetricRows ë“±)í•˜ë¯€ë¡œ ê¹Šì€ ë³µì‚¬ í•„ìš”
    List<Map<String, Object>> originalTable = baseContext.getTable();
    List<Map<String, Object>> copiedTable = new ArrayList<>();

    for (Map<String, Object> originalRow : originalTable) {
        Map<String, Object> copiedRow = new LinkedHashMap<>(originalRow);
        copiedTable.add(copiedRow);
    }

    return new TrendContext(mxHistories, eqpIds, copiedTable);
}












ì •ë ¬ ê°œì„ 


/**
 * ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ ì •ë ¬
 * - ê¸°ë³¸: actionName â†’ component â†’ (yearWeek ì¡´ì¬ ì‹œ yearWeek)
 * - íŠ¹ìˆ˜ actionName(sum, dailyMActionCount, mxPerDayMin)ì€ í•­ìƒ ë§ˆì§€ë§‰
 */
private List<Map<String, Object>> sortTrendRows(List<Map<String, Object>> rows) {

    if (rows == null || rows.isEmpty()) {
        return rows;
    }

    List<String> specialActions = Arrays.asList(
        "sum",
        "dailyMActionCount",
        "mxPerDayMin"
    );

    boolean hasYearWeek = rows.stream()
        .anyMatch(row -> row.get("yearWeek") != null);

    // ê¸°ë³¸ comparator: actionName â†’ component
    Comparator<Map<String, Object>> baseComparator =
        Comparator.<Map<String, Object>, String>comparing(
                row -> (String) row.get("actionName"),
                Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER)
        ).thenComparing(
                row -> (String) row.get("component"),
                Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER)
        );

    // yearWeekê°€ ìˆìœ¼ë©´ yearWeekê¹Œì§€ í¬í•¨í•œ comparator ìƒì„±
    Comparator<Map<String, Object>> fullComparator = hasYearWeek
        ? baseComparator.thenComparing(
                row -> (String) row.get("yearWeek"),
                Comparator.nullsLast(String::compareTo)
          )
        : baseComparator; // ì¬í• ë‹¹ ì—†ì´ í•œ ë²ˆë§Œ ëŒ€ì…

    rows.sort((rowA, rowB) -> {
        String actionA = (String) rowA.get("actionName");
        String actionB = (String) rowB.get("actionName");

        boolean isSpecialA = specialActions.contains(actionA);
        boolean isSpecialB = specialActions.contains(actionB);

        // í•œìª½ë§Œ íŠ¹ìˆ˜í–‰ì´ë©´ â†’ ì¼ë°˜í–‰ ë¨¼ì €, íŠ¹ìˆ˜í–‰ì€ ë’¤ë¡œ
        if (isSpecialA && !isSpecialB) {
            return 1;
        }
        if (!isSpecialA && isSpecialB) {
            return -1;
        }

        // ë‘˜ ë‹¤ ì¼ë°˜ or ë‘˜ ë‹¤ íŠ¹ìˆ˜ â†’ ê¸°ë³¸ ì •ë ¬ ê·œì¹™ ì‚¬ìš©
        return fullComparator.compare(rowA, rowB);
    });

    return rows;
}






ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡ã…¡

ì„±ëŠ¥ ê°œì„ 




/**
 * ê³µí†µ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
 * - departments, ê¸°ê°„ ì¡°ê±´ìœ¼ë¡œ mxHistories ì¡°íšŒ
 * - EQP ëª©ë¡ ì¶”ì¶œ
 * - í”¼ë²— ìƒì„±
 * - ê¸°ë³¸ í…Œì´ë¸” ìƒì„± (ActionName, component, eqpId ì»¬ëŸ¼)
 */
private TrendContext createContext(List<String> departments, String startDate, String endDate) {
    if (departments == null || departments.isEmpty()) {
        return null;
    }

    List<MxHistoryRow> mxHistories =
        mxMapper.getAllMxHistoryByDepartments(departments, startDate, endDate);
    if (mxHistories == null || mxHistories.isEmpty()) {
        return null;
    }

    // ğŸ‘‰ ì—¬ê¸°ì„œë¶€í„°ëŠ” ê³µí†µ ë¡œì§ì´ë¯€ë¡œ ì•„ë˜ ì˜¤ë²„ë¡œë“œë¡œ ìœ„ì„
    return createContext(mxHistories);
}

/**
 * ê³µí†µ ì»¨í…ìŠ¤íŠ¸ ìƒì„± (ì´ë¯¸ ì¡°íšŒëœ mxHistoriesë¡œë¶€í„°)
 * - EQP ëª©ë¡ ì¶”ì¶œ
 * - í”¼ë²— ìƒì„±
 * - ê¸°ë³¸ í…Œì´ë¸” ìƒì„± (ActionName, component, eqpId ì»¬ëŸ¼)
 */
private TrendContext createContext(List<MxHistoryRow> mxHistories) {
    if (mxHistories == null || mxHistories.isEmpty()) {
        return null;
    }

    List<String> eqpIds = extractEqpIds(mxHistories);
    Map<String, Map<String, Double>> pivot = buildPivot(mxHistories);
    List<Map<String, Object>> table = buildBaseTable(pivot, eqpIds);

    return new TrendContext(mxHistories, eqpIds, table);
}






public Map<String, Object> getActionAndEqpData(
        List<String> departments,
        String startDate,
        String endDate
) {
    List<Map<String, Object>> actionTrend = new ArrayList<>();
    List<Map<String, Object>> eqpTrend = new ArrayList<>();

    WeekUtils weekUtils = new WeekUtils();
    List<WeekInfo> weekInfos = weekUtils.getSundayWeeksInDateRange(startDate, endDate);

    if (departments == null || departments.isEmpty() || weekInfos.isEmpty()) {
        Map<String, Object> emptyResult = new LinkedHashMap<>();
        emptyResult.put("actionTrend", Collections.emptyList());
        emptyResult.put("eqpTrend", Collections.emptyList());
        return emptyResult;
    }

    // âœ… 1) ì „ì²´ ê¸°ê°„ì— ëŒ€í•´ í•œ ë²ˆë§Œ ì¡°íšŒ
    List<MxHistoryRow> allHistories =
        mxMapper.getAllMxHistoryByDepartments(departments, startDate, endDate);
    if (allHistories == null || allHistories.isEmpty()) {
        Map<String, Object> emptyResult = new LinkedHashMap<>();
        emptyResult.put("actionTrend", Collections.emptyList());
        emptyResult.put("eqpTrend", Collections.emptyList());
        return emptyResult;
    }

    // âœ… 2) ì£¼ì°¨ë³„ë¡œ ë¯¸ë¦¬ ë‚˜ëˆ„ê¸° (í‚¤ = weekLabel, ì˜ˆ: 2025_W36)
    Map<String, List<MxHistoryRow>> historiesByWeek =
        groupHistoriesByWeek(allHistories, weekInfos, weekUtils);

    // âœ… 3) ì£¼ì°¨ë³„ë¡œ context ë§Œë“¤ì–´ì„œ ê¸°ì¡´ ë¡œì§ ì¬ì‚¬ìš©
    for (WeekInfo weekInfo : weekInfos) {
        String weekLabel = weekUtils.formatWeekLabel(weekInfo);
        List<MxHistoryRow> weekHistories =
            historiesByWeek.getOrDefault(weekLabel, Collections.emptyList());

        if (weekHistories.isEmpty()) {
            continue;
        }

        TrendContext actionContext = createContext(weekHistories);
        TrendContext eqpContext = copyContext(actionContext);

        if (actionContext != null) {
            List<Map<String, Object>> actionData =
                getActionTrendData(actionContext, weekLabel);
            actionTrend.addAll(actionData);
        }
        if (eqpContext != null) {
            List<Map<String, Object>> eqpData =
                getEqpTrendData(eqpContext, weekLabel);
            eqpTrend.addAll(eqpData);
        }
    }

    Map<String, Object> result = new LinkedHashMap<>();
    result.put("actionTrend", sortTrendRows(actionTrend));
    result.put("eqpTrend", sortTrendRows(eqpTrend));
    return result;
}











/**
 * ì „ì²´ mxHistoriesë¥¼ weekInfos ê¸°ì¤€ìœ¼ë¡œ ì£¼ì°¨ë³„ë¡œ ë‚˜ëˆ„ê¸°
 * - key: weekLabel (ì˜ˆ: "2025_W36")
 * - value: í•´ë‹¹ ì£¼ì— ì†í•˜ëŠ” MxHistoryRow ë¦¬ìŠ¤íŠ¸
 */
private Map<String, List<MxHistoryRow>> groupHistoriesByWeek(
        List<MxHistoryRow> allHistories,
        List<WeekInfo> weekInfos,
        WeekUtils weekUtils
) {
    Map<String, List<MxHistoryRow>> grouped = new LinkedHashMap<>();

    if (allHistories == null || allHistories.isEmpty() || weekInfos == null || weekInfos.isEmpty()) {
        return grouped;
    }

    for (WeekInfo weekInfo : weekInfos) {
        String weekLabel = weekUtils.formatWeekLabel(weekInfo);
        String weekStart = weekInfo.getStartDate(); // WeekInfoì— ë§ê²Œ ë©”ì„œë“œëª… ì¡°ì • í•„ìš”
        String weekEnd = weekInfo.getEndDate();     // ì˜ˆ: [weekStart, weekEnd) ë˜ëŠ” [weekStart, weekEnd] ê·œì¹™ì— ë§ì¶° ì‚¬ìš©

        List<MxHistoryRow> weekRows = allHistories.stream()
            .filter(row -> isWithinRange(row.getSummaryDate(), weekStart, weekEnd))
            .collect(Collectors.toList());

        if (!weekRows.isEmpty()) {
            grouped.put(weekLabel, weekRows);
        }
    }

    return grouped;
}

/**
 * summaryDateê°€ [startDate, endDate) êµ¬ê°„ì— í¬í•¨ë˜ëŠ”ì§€ ì—¬ë¶€
 * - ë‚ ì§œ í¬ë§·ì´ "yyyy-MM-dd" ë¼ê³  ê°€ì •í•˜ê³  ë¬¸ìì—´ ë¹„êµ
 */
private boolean isWithinRange(String summaryDate, String startDate, String endDate) {
    if (summaryDate == null || startDate == null || endDate == null) {
        return false;
    }
    return summaryDate.compareTo(startDate) >= 0
        && summaryDate.compareTo(endDate) < 0; // endDate í¬í•¨/ë¯¸í¬í•¨ì€ WeekUtils ê·œì¹™ì— ë§ê²Œ ì¡°ì •
}