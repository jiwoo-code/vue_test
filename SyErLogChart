<template>
  <div class="sy-erlog-wrap">
    <div class="legend-row">
      <button
        type="button"
        class="legend-item"
        :class="{ off: !legendFilter.hasSy }"
        @click="toggleLegend('hasSy')"
      >
        <span class="swatch has-sy"></span>
        <span>Has SY Data</span>
      </button>

      <button
        type="button"
        class="legend-item"
        :class="{ off: !legendFilter.incompleteSy }"
        @click="toggleLegend('incompleteSy')"
      >
        <span class="swatch incomplete"></span>
        <span>Has Incomplete SY Data</span>
      </button>

      <button
        type="button"
        class="legend-item"
        :class="{ off: !legendFilter.reject }"
        @click="toggleLegend('reject')"
      >
        <span class="swatch reject"></span>
        <span>Has Reject Wafer</span>
      </button>
    </div>

    <v-chart
      class="sy-erlog-chart"
      :option="chartOption"
      :autoresize="true"
      @ready="onChartReady"
      @click="onChartClick"
    />
  </div>
</template>

<script>
import { use, graphic } from 'echarts/core';
import { CanvasRenderer } from 'echarts/renderers';
import { CustomChart } from 'echarts/charts';
import { GridComponent, TooltipComponent, DataZoomComponent } from 'echarts/components';
import VChart from 'vue-echarts';

use([CanvasRenderer, CustomChart, GridComponent, TooltipComponent, DataZoomComponent]);

const COLOR_RULES = Object.freeze({
  hasSy: '#3b82f6',
  incompleteSy: '#f59e0b',
  reject: '#ef4444'
});

const TOOLTIP_TEXT_COLOR = Object.freeze({
  [COLOR_RULES.hasSy]: '#ffffff',
  [COLOR_RULES.incompleteSy]: '#111827',
  [COLOR_RULES.reject]: '#ffffff'
});

export default {
  name: 'SyErLogChart',
  components: {
    'v-chart': VChart
  },
  data() {
    return {
      chart: null,
      items: [],

      // =====================
      // 축 고정용(전체 데이터 기준)
      // =====================
      baseCategories: [],
      baseDomainStart: 0,
      baseDomainEnd: 0,
      categoryIndexMap: new Map(),

      // =====================
      // 현재 뷰(줌) 유지용
      // =====================
      viewStart: 0,
      viewEnd: 0,
      isViewInitialized: false,

      // =====================
      // 실제 렌더링 데이터
      // =====================
      seriesData: [],

      legendFilter: {
        hasSy: true,
        incompleteSy: true,
        reject: true
      },

      onDataZoomHandler: null
    };
  },
  beforeDestroy() {
    this.teardownChart();
  },
  computed: {
    chartOption() {
      const base = this.buildBaseOption();

      const dataZoom = base.dataZoom.map((item) => {
        if (item && item.id === 'erlog-slider') {
          return {
            ...item,
            startValue: this.viewStart,
            endValue: this.viewEnd
          };
        }
        return item;
      });

      const series = base.series.map((item) => {
        if (item && item.id === 'erlog-series') {
          return {
            ...item,
            data: this.seriesData
          };
        }
        return item;
      });

      return {
        ...base,
        xAxis: {
          ...base.xAxis,
          min: this.baseDomainStart,
          max: this.baseDomainEnd
        },
        yAxis: {
          ...base.yAxis,
          data: this.baseCategories
        },
        dataZoom,
        series
      };
    }
  },
  methods: {
    // =====================
    // 차트 라이프사이클
    // =====================
    onChartReady(chart) {
      this.chart = chart;
      this.bindDataZoomEvent();
    },
    teardownChart() {
      if (!this.chart) return;
      this.unbindDataZoomEvent();
      this.hideTooltip();
      this.chart = null;
    },
    bindDataZoomEvent() {
      if (!this.chart) return;

      if (!this.onDataZoomHandler) {
        this.onDataZoomHandler = () => {
          this.syncViewFromChart();
        };
      }

      this.chart.on('datazoom', this.onDataZoomHandler);
    },
    unbindDataZoomEvent() {
      if (!this.chart || !this.onDataZoomHandler) return;
      this.chart.off('datazoom', this.onDataZoomHandler);
    },

    // =====================
    // 범례 토글
    // =====================
    toggleLegend(key) {
      const current = this.legendFilter[key];
      if (typeof current !== 'boolean') return;

      this.legendFilter = {
        ...this.legendFilter,
        [key]: !current
      };

      // 축은 고정, 시리즈만 재생성
      this.seriesData = this.buildSeriesData(this.items);
      this.hideTooltip();
    },

    // =====================
    // 데이터 갱신
    // =====================
    setData(data) {
      this.items = Array.isArray(data) ? data : [];

      // ✅ 전체 데이터 기준으로 축(카테고리/도메인) 고정 값 갱신
      this.prepareBaseAxis(this.items);

      // ✅ 데이터가 새로 들어온 경우: 뷰(줌)도 전체 범위로 초기화
      this.resetViewToBase();

      // ✅ 필터 상태에 맞게 시리즈 생성
      this.seriesData = this.buildSeriesData(this.items);
    },

    // =====================
    // 축(카테고리/도메인) 고정 준비
    // =====================
    prepareBaseAxis(items) {
      const categories = [];
      const categoryIndexMap = new Map();

      let minTime = null;
      let maxTime = null;

      items.forEach((item) => {
        if (!item) return;

        const eqpId = item.eqpId ?? 'EQP-UNKNOWN';
        if (!categoryIndexMap.has(eqpId)) {
          categoryIndexMap.set(eqpId, categories.length);
          categories.push(eqpId);
        }

        const start = this.toTimeValue(item.lotStart);
        const end = this.toTimeValue(item.lotFinish);
        if (start == null || end == null) return;

        minTime = minTime == null ? start : Math.min(minTime, start);
        maxTime = maxTime == null ? end : Math.max(maxTime, end);
      });

      if (minTime == null || maxTime == null) {
        const now = Date.now();
        minTime = now - 60 * 60 * 1000;
        maxTime = now + 60 * 60 * 1000;
      }

      const padding = 20 * 60 * 1000;

      this.baseCategories = categories;
      this.categoryIndexMap = categoryIndexMap;
      this.baseDomainStart = minTime - padding;
      this.baseDomainEnd = maxTime + padding;
    },

    resetViewToBase() {
      this.viewStart = this.baseDomainStart;
      this.viewEnd = this.baseDomainEnd;
      this.isViewInitialized = true;
    },

    // =====================
    // 현재 줌(뷰) 구간 동기화
    // =====================
    syncViewFromChart() {
      if (!this.chart) return;

      const option = this.chart.getOption();
      const dataZoomList = option && option.dataZoom ? option.dataZoom : null;
      if (!Array.isArray(dataZoomList) || dataZoomList.length === 0) return;

      const sliderZoom = dataZoomList.find((item) => item && item.id === 'erlog-slider');
      if (!sliderZoom) return;

      const startValue = sliderZoom.startValue;
      const endValue = sliderZoom.endValue;

      if (typeof startValue === 'number' && typeof endValue === 'number') {
        this.viewStart = startValue;
        this.viewEnd = endValue;
        this.isViewInitialized = true;
      }
    },

    // =====================
    // 시리즈 데이터 생성(필터 적용)
    // =====================
    buildSeriesData(items) {
      const seriesData = [];

      items.forEach((item) => {
        if (!item) return;

        const type = this.resolveType(item);
        if (!this.legendFilter[type]) return;

        const eqpId = item.eqpId ?? 'EQP-UNKNOWN';
        const categoryIndex = this.categoryIndexMap.get(eqpId);
        if (categoryIndex == null) return;

        const start = this.toTimeValue(item.lotStart);
        const end = this.toTimeValue(item.lotFinish);
        if (start == null || end == null) return;

        const color = COLOR_RULES[type];

        seriesData.push({
          name: item.lotId,
          value: [categoryIndex, start, end, Math.max(0, end - start)],
          itemStyle: {
            color
          },
          tooltipHtml: this.buildTooltipHtml(item, color),
          payload: {
            ...item
          }
        });
      });

      return seriesData;
    },

    resolveType(item) {
      if (item.rejectWafer >= 1) return 'reject';
      if (item.avgSyCount >= 63) return 'hasSy';
      return 'incompleteSy';
    },

    // =====================
    // 차트 옵션
    // =====================
    buildBaseOption() {
      return {
        backgroundColor: '#ffffff',
        animation: false,
        grid: {
          left: 80,
          right: 32,
          top: 20,
          bottom: 120
        },
        tooltip: {
          trigger: 'item',
          triggerOn: 'mousemove',
          confine: false,
          appendToBody: true,
          className: 'erlog-tooltip',
          backgroundColor: 'transparent',
          borderWidth: 0,
          padding: 0,
          showDelay: 0,
          hideDelay: 0,
          transitionDuration: 0,
          extraCssText: 'box-shadow: none; pointer-events: none;',
          position: (pos, params, dom, rect, size) => this.getTooltipPosition(pos, size),
          formatter: this.getTooltipHtml
        },
        dataZoom: [
          {
            id: 'erlog-slider',
            type: 'slider',
            xAxisIndex: 0,
            filterMode: 'weakFilter',
            showDataShadow: false,
            brushSelect: false,
            bottom: 10,
            height: 22,
            labelFormatter: '',
            startValue: 0,
            endValue: 0
          },
          {
            id: 'erlog-inside',
            type: 'inside',
            xAxisIndex: 0,
            filterMode: 'weakFilter',
            zoomOnMouseWheel: true,
            moveOnMouseWheel: false,
            moveOnMouseMove: false
          }
        ],
        xAxis: {
          type: 'time',
          min: 0,
          max: 0,
          minInterval: 30 * 60 * 1000,
          splitNumber: 48,
          axisLine: {
            lineStyle: {
              color: '#cbd5e1'
            }
          },
          axisLabel: {
            color: '#475569',
            interval: 0,
            hideOverlap: true,
            rotate: 90,
            margin: 6,
            inside: false,
            formatter: (value) => this.formatAxisLabel(value)
          },
          splitLine: {
            show: true,
            lineStyle: {
              color: '#e2e8f0'
            }
          }
        },
        yAxis: {
          type: 'category',
          inverse: true,
          data: [],
          axisTick: { show: false },
          axisLine: { show: false },
          axisLabel: {
            color: '#334155'
          }
        },
        series: [
          {
            id: 'erlog-series',
            type: 'custom',
            renderItem: this.renderItem,
            itemStyle: {
              opacity: 0.92
            },
            encode: {
              x: [1, 2],
              y: 0
            },
            data: []
          }
        ]
      };
    },

    // =====================
    // 시리즈 렌더링
    // =====================
    renderItem(params, api) {
      const categoryIndex = api.value(0);
      const start = api.coord([api.value(1), categoryIndex]);
      const end = api.coord([api.value(2), categoryIndex]);
      const height = 35;

      const rectShape = graphic.clipRectByRect(
        {
          x: start[0],
          y: start[1] - height / 2,
          width: end[0] - start[0],
          height
        },
        {
          x: params.coordSys.x,
          y: params.coordSys.y,
          width: params.coordSys.width,
          height: params.coordSys.height
        }
      );

      return (
        rectShape && {
          type: 'rect',
          transition: ['shape'],
          shape: rectShape,
          style: api.style()
        }
      );
    },

    // =====================
    // 차트 인터랙션
    // =====================
    onChartClick(params) {
      if (!params || params.seriesId !== 'erlog-series' || !params.data) return;

      const payload = params.data.payload;
      if (!payload) return;

      const clickedTime = this.getClickedTime(params);

      this.hideTooltip();
      this.$emit('select-lot', {
        lot: payload,
        clickedTime
      });
    },

    getClickedTime(params) {
      const data = params && params.data;
      const start = data && data.value ? data.value[1] : null;
      const end = data && data.value ? data.value[2] : null;

      if (!this.chart || !params || !params.event) return start;

      const offsetX = params.event.offsetX;
      const offsetY = params.event.offsetY;
      if (offsetX == null || offsetY == null) return start;

      const value = this.chart.convertFromPixel({ xAxisIndex: 0 }, [offsetX, offsetY]);
      const candidate = Array.isArray(value) ? value[0] : value;

      if (typeof candidate === 'number' && !Number.isNaN(candidate)) {
        if (start != null && end != null) {
          return Math.min(Math.max(candidate, start), end);
        }
        return candidate;
      }

      return start;
    },

    // =====================
    // 툴팁 헬퍼
    // =====================
    hideTooltip() {
      if (this.chart) {
        this.chart.dispatchAction({ type: 'hideTip' });
      }
      this.clearTooltip();
    },
    clearTooltip() {
      if (typeof document === 'undefined') return;

      const nodes = document.querySelectorAll('.erlog-tooltip, .echarts-tooltip');
      nodes.forEach((node) => {
        if (node && node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });
    },
    getTooltipHtml(params) {
      const data = params && params.data ? params.data : null;
      return data && data.tooltipHtml ? data.tooltipHtml : '';
    },
    buildTooltipHtml(item, color) {
      if (!item) return '';

      const textColor = TOOLTIP_TEXT_COLOR[color] || '#ffffff';
      const lines = [
        `Lot ID: ${this.safeText(item.lotId)}`,
        `Layer: ${this.safeText(item.layer)}`,
        `Device: ${this.safeText(item.device)}`,
        `Lot Start: ${this.safeText(item.lotStart)}`,
        `Lot Finish: ${this.safeText(item.lotFinish)}`,
        `Lot Size: ${this.safeText(item.lotSize)}`,
        `Reject Wafer: ${this.safeText(item.rejectWafer)}`
      ].join('<br/>');

      return [
        '<div style="',
        `background:${color};`,
        `color:${textColor};`,
        'padding:8px 10px;',
        'border-radius:8px;',
        'font-size:12px;',
        'line-height:1.5;',
        'box-shadow:0 10px 20px rgba(15,23,42,0.2);',
        '">',
        lines,
        '</div>'
      ].join('');
    },
    safeText(value) {
      return value == null ? '-' : String(value);
    },
    getTooltipPosition(pos, size) {
      if (!pos || !size || !Array.isArray(pos)) return pos;

      const margin = 8;
      const viewWidth = size.viewSize[0];
      const viewHeight = size.viewSize[1];
      const contentWidth = size.contentSize[0];
      const contentHeight = size.contentSize[1];

      let left = pos[0] + margin;
      let top = pos[1] - contentHeight - margin;

      if (top < margin) top = pos[1] + margin;
      if (left + contentWidth + margin > viewWidth) left = viewWidth - contentWidth - margin;
      if (left < margin) left = margin;
      if (top + contentHeight + margin > viewHeight) top = viewHeight - contentHeight - margin;
      if (top < margin) top = margin;

      return [left, top];
    },

    // =====================
    // 포맷팅
    // =====================
    formatAxisLabel(value) {
      const date = new Date(value);
      if (Number.isNaN(date.getTime())) return '';

      return [
        `${this.pad2(date.getMonth() + 1)}-${this.pad2(date.getDate())}`,
        `${this.pad2(date.getHours())}:${this.pad2(date.getMinutes())}`
      ].join(' ');
    },
    pad2(value) {
      return String(value).padStart(2, '0');
    },

    // =====================
    // 시간 파싱
    // =====================
    toTimeValue(value) {
      if (value == null) return null;
      if (typeof value === 'number') return value;

      const parsed = this.parseDateTimeMs(value);
      if (parsed != null) return parsed;

      const time = new Date(value).getTime();
      return Number.isNaN(time) ? null : time;
    },
    parseDateTimeMs(value) {
      const match = /^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})\.(\d{3})$/.exec(
        String(value ?? '').trim()
      );
      if (!match) return null;

      const [, year, month, day, hour, minute, second, ms] = match;

      const date = new Date(
        Number(year),
        Number(month) - 1,
        Number(day),
        Number(hour),
        Number(minute),
        Number(second),
        Number(ms)
      );

      return Number.isNaN(date.getTime()) ? null : date.getTime();
    }
  }
};
</script>

<style scoped>
.sy-erlog-wrap {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.legend-row {
  display: flex;
  justify-content: flex-end;
  gap: 10px 16px;
  flex-wrap: wrap;
  font-size: 12px;
}

.legend-item {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  border: 0;
  background: transparent;
  padding: 0;
  cursor: pointer;
  color: #334155;
}

.legend-item.off {
  opacity: 0.35;
}

.swatch {
  width: 10px;
  height: 10px;
  border-radius: 999px;
  display: inline-block;
}

.swatch.has-sy {
  background: #3b82f6;
}

.swatch.incomplete {
  background: #f59e0b;
}

.swatch.reject {
  background: #ef4444;
}

.sy-erlog-chart {
  width: 100%;
  height: 220px;
  border-radius: 14px;
  overflow: hidden;
  background: #ffffff;
  border: 1px solid rgba(15, 23, 42, 0.12);
}
</style>